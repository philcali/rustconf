//! Example application demonstrating rustconf usage.
//!
//! This example shows how to use the generated type-safe Rust bindings
//! from YANG specifications. It demonstrates:
//! - Creating and using generated types (Interface, InterfaceConfig)
//! - Serialization and deserialization with serde_json
//! - Validation error handling for constrained types
//! - Working with enums, optional fields, and nested structures
//!
//! # Requirements Validated
//! - Requirement 6.1: Example module demonstrating basic usage patterns
//! - Requirement 6.4: Shows how to use generated types for RESTCONF operations
//!
//! # Running the Example
//! ```bash
//! cargo run -p interface-config
//! ```
//!
//! # Note
//! This example assumes the YANG parser successfully generates the bindings.
//! The generated types include validation logic that enforces YANG constraints
//! at runtime, providing type-safe access to RESTCONF data models.

// Include the generated code from the build script
include!(concat!(env!("OUT_DIR"), "/interface_config.rs"));

use serde_json;

fn main() {
    println!("=== rustconf Example: Interface Configuration ===\n");

    // Demonstrate creating instances of generated types
    demonstrate_type_creation();

    // Demonstrate JSON serialization
    demonstrate_serialization();

    // Demonstrate JSON deserialization
    demonstrate_deserialization();

    // Demonstrate validation error handling
    demonstrate_validation_errors();

    // Demonstrate working with optional fields
    demonstrate_optional_fields();

    // Demonstrate working with enums and choices
    demonstrate_enums_and_choices();

    // Note: RESTCONF operation functions (GET, POST, PUT, PATCH, DELETE)
    // would be demonstrated here if they are generated by the code generator.
    // The generated operations would provide type-safe methods for interacting
    // with RESTCONF servers using the data types shown above.

    println!("\n=== Example Complete ===");
    println!("All demonstrations passed successfully!");
}

/// Demonstrate creating instances of generated types
fn demonstrate_type_creation() {
    println!("--- Creating Generated Types ---");

    // Create an interface configuration
    let config = InterfaceConfig {
        enabled: Some(true),
        mtu: Some(MtuType::new(1500).expect("Valid MTU")),
        address_type: Some(AddressType::Ipv4 {
            ipv4_address: "192.168.1.1/24".to_string(),
        }),
        speed: Some(Speed::_1G),
        duplex: Some(Duplex::Full),
    };

    println!("Created InterfaceConfig:");
    println!("  enabled: {:?}", config.enabled);
    println!("  mtu: {:?}", config.mtu);
    println!("  address_type: {:?}", config.address_type);
    println!("  speed: {:?}", config.speed);
    println!("  duplex: {:?}", config.duplex);

    // Assertions to verify correct values
    assert_eq!(config.enabled, Some(true));
    assert!(config.mtu.is_some());
    assert!(matches!(config.address_type, Some(AddressType::Ipv4 { .. })));

    // Create interface state
    let state = InterfaceState {
        admin_status: AdminStatus::Up,
        oper_status: OperStatus::Up,
        last_change: Some(0),
        in_octets: Some(1000000),
        in_packets: Some(10000),
        in_errors: Some(0),
        out_octets: Some(2000000),
        out_packets: Some(15000),
        out_errors: Some(0),
    };

    println!("\nCreated InterfaceState:");
    println!("  admin_status: {:?}", state.admin_status);
    println!("  oper_status: {:?}", state.oper_status);
    println!("  in_packets: {:?}", state.in_packets);
    println!("  out_packets: {:?}", state.out_packets);

    // Assertions to verify state values
    assert_eq!(state.admin_status, AdminStatus::Up);
    assert_eq!(state.oper_status, OperStatus::Up);
    assert_eq!(state.in_packets, Some(10000));
    assert_eq!(state.out_packets, Some(15000));

    // Create a complete interface
    let interface = Interface {
        name: InterfaceName::new("eth0".to_string()).expect("Valid interface name"),
        description: Some("Primary network interface".to_string()),
        type_: InterfaceType::Ethernet,
        config: Some(config),
        state: Some(state),
    };

    println!("\nCreated Interface:");
    println!("  name: {:?}", interface.name);
    println!("  description: {:?}", interface.description);
    println!("  type: {:?}", interface.type_);

    // Assertions to verify interface structure
    assert_eq!(interface.name.value(), "eth0");
    assert_eq!(interface.type_, InterfaceType::Ethernet);
    assert!(interface.config.is_some());
    assert!(interface.state.is_some());
    
    println!();
}

/// Demonstrate JSON serialization
fn demonstrate_serialization() {
    println!("--- JSON Serialization ---");

    // Create a simple interface
    let interface = Interface {
        name: InterfaceName::new("eth0".to_string()).expect("Valid interface name"),
        description: Some("Primary Ethernet interface".to_string()),
        type_: InterfaceType::Ethernet,
        config: Some(InterfaceConfig {
            enabled: Some(true),
            mtu: Some(MtuType::new(1500).expect("Valid MTU")),
            address_type: Some(AddressType::Ipv4 {
                ipv4_address: "10.0.0.1/24".to_string(),
            }),
            speed: Some(Speed::_1G),
            duplex: Some(Duplex::Full),
        }),
        state: Some(InterfaceState {
            admin_status: AdminStatus::Up,
            oper_status: OperStatus::Up,
            last_change: Some(0),
            in_octets: Some(500000),
            in_packets: Some(5000),
            in_errors: Some(0),
            out_octets: Some(750000),
            out_packets: Some(7500),
            out_errors: Some(0),
        }),
    };

    // Serialize to JSON
    let json = serde_json::to_string_pretty(&interface).expect("Serialization should succeed");
    println!("Serialized Interface to JSON:");
    println!("{}", json);
    println!();
}

/// Demonstrate JSON deserialization
fn demonstrate_deserialization() {
    println!("--- JSON Deserialization ---");

    // JSON representation of an interface
    let json_data = r#"{
  "name": "eth1",
  "description": "Secondary network interface",
  "type": "ethernet",
  "config": {
    "enabled": true,
    "mtu": 9000,
    "address-type": {
      "ipv4-address": "172.16.0.1/16"
    },
    "speed": "10G",
    "duplex": "full"
  },
  "state": {
    "admin-status": "up",
    "oper-status": "up",
    "last-change": 3600,
    "in-octets": 1000000000,
    "in-packets": 1000000,
    "in-errors": 10,
    "out-octets": 2000000000,
    "out-packets": 2000000,
    "out-errors": 5
  }
}"#;

    // Deserialize from JSON
    match serde_json::from_str::<Interface>(json_data) {
        Ok(interface) => {
            println!("Successfully deserialized Interface:");
            println!("  name: {:?}", interface.name);
            println!("  type: {:?}", interface.type_);
            
            // Assertions to verify deserialized data
            assert_eq!(interface.name.value(), "eth1");
            assert_eq!(interface.type_, InterfaceType::Ethernet);
            
            if let Some(config) = &interface.config {
                println!("  config.enabled: {:?}", config.enabled);
                println!("  config.mtu: {:?}", config.mtu);
                println!("  config.speed: {:?}", config.speed);
                
                assert_eq!(config.enabled, Some(true));
                assert_eq!(config.mtu.as_ref().map(|m| m.value()), Some(9000));
                assert_eq!(config.speed, Some(Speed::_10G));
            }
            
            if let Some(state) = &interface.state {
                println!("  state.admin_status: {:?}", state.admin_status);
                println!("  state.in_packets: {:?}", state.in_packets);
                
                assert_eq!(state.admin_status, AdminStatus::Up);
                assert_eq!(state.in_packets, Some(1000000));
            }
        }
        Err(e) => {
            println!("Deserialization failed: {}", e);
            panic!("Expected successful deserialization");
        }
    }
    println!();
}

/// Demonstrate validation error handling
fn demonstrate_validation_errors() {
    println!("--- Validation Error Handling ---");

    // Try to create an MTU with an invalid value (too small)
    println!("Attempting to create MTU with value 50 (below minimum 68):");
    match MtuType::new(50) {
        Ok(_) => {
            println!("  Unexpectedly succeeded!");
            panic!("Expected validation error for MTU below minimum");
        }
        Err(e) => println!("  Validation error (expected): {:?}", e),
    }

    // Try to create an MTU with an invalid value (too large)
    println!("\nAttempting to create MTU with value 10000 (above maximum 9000):");
    match MtuType::new(10000) {
        Ok(_) => {
            println!("  Unexpectedly succeeded!");
            panic!("Expected validation error for MTU above maximum");
        }
        Err(e) => println!("  Validation error (expected): {:?}", e),
    }

    // Try to create a valid MTU
    println!("\nAttempting to create MTU with value 1500 (valid):");
    match MtuType::new(1500) {
        Ok(mtu) => {
            println!("  Success! MTU value: {}", mtu.value());
            assert_eq!(mtu.value(), 1500);
        }
        Err(e) => {
            println!("  Unexpected error: {:?}", e);
            panic!("Expected successful MTU creation");
        }
    }

    // Try to create an interface name with invalid characters
    println!("\nAttempting to create interface name with invalid characters:");
    match InterfaceName::new("eth@0!".to_string()) {
        Ok(_) => {
            println!("  Unexpectedly succeeded!");
            panic!("Expected validation error for invalid interface name");
        }
        Err(e) => println!("  Validation error (expected): {:?}", e),
    }

    // Try to create a valid interface name
    println!("\nAttempting to create interface name 'eth0' (valid):");
    match InterfaceName::new("eth0".to_string()) {
        Ok(name) => {
            println!("  Success! Interface name: {}", name.value());
            assert_eq!(name.value(), "eth0");
        }
        Err(e) => {
            println!("  Unexpected error: {:?}", e);
            panic!("Expected successful interface name creation");
        }
    }

    // Demonstrate deserialization validation
    println!("\nAttempting to deserialize interface with invalid MTU:");
    let invalid_json = r#"{
  "name": "eth0",
  "type": "ethernet",
  "config": {
    "mtu": 50
  }
}"#;

    match serde_json::from_str::<Interface>(invalid_json) {
        Ok(_) => {
            println!("  Unexpectedly succeeded!");
            panic!("Expected deserialization error for invalid MTU");
        }
        Err(e) => println!("  Deserialization error (expected): {}", e),
    }
    println!();
}

/// Demonstrate working with optional fields
fn demonstrate_optional_fields() {
    println!("--- Optional Fields ---");

    // Create an interface with minimal required fields
    let minimal_interface = Interface {
        name: InterfaceName::new("lo0".to_string()).expect("Valid interface name"),
        description: None, // Optional field omitted
        type_: InterfaceType::Loopback,
        config: None, // Optional container omitted
        state: None,  // Optional container omitted
    };

    println!("Created minimal Interface (only required fields):");
    println!("  name: {:?}", minimal_interface.name);
    println!("  description: {:?}", minimal_interface.description);
    println!("  type: {:?}", minimal_interface.type_);
    println!("  config: {:?}", minimal_interface.config);
    println!("  state: {:?}", minimal_interface.state);

    // Serialize to JSON - optional fields should be omitted
    let json = serde_json::to_string_pretty(&minimal_interface)
        .expect("Serialization should succeed");
    println!("\nSerialized minimal Interface (optional fields omitted):");
    println!("{}", json);

    // Create an interface with some optional fields
    let partial_interface = Interface {
        name: InterfaceName::new("tun0".to_string()).expect("Valid interface name"),
        description: Some("VPN tunnel interface".to_string()),
        type_: InterfaceType::Tunnel,
        config: Some(InterfaceConfig {
            enabled: Some(true),
            mtu: Some(MtuType::new(1400).expect("Valid MTU")),
            address_type: None, // Optional choice omitted
            speed: None,        // Optional field omitted
            duplex: None,       // Optional field omitted
        }),
        state: None,
    };

    println!("\nCreated partial Interface (some optional fields):");
    println!("  name: {:?}", partial_interface.name);
    println!("  description: {:?}", partial_interface.description);
    println!("  config.enabled: {:?}", partial_interface.config.as_ref().unwrap().enabled);
    println!("  config.mtu: {:?}", partial_interface.config.as_ref().unwrap().mtu);
    println!("  config.address_type: {:?}", partial_interface.config.as_ref().unwrap().address_type);
    println!();
}

/// Demonstrate working with enums and choices
fn demonstrate_enums_and_choices() {
    println!("--- Enums and Choices ---");

    // Demonstrate interface type enum
    println!("Interface types (enum):");
    let types = vec![
        InterfaceType::Ethernet,
        InterfaceType::Loopback,
        InterfaceType::Tunnel,
    ];
    for t in types {
        println!("  {:?}", t);
    }

    // Demonstrate speed enum
    println!("\nInterface speeds (enum):");
    let speeds = vec![
        Speed::_10M,
        Speed::_100M,
        Speed::_1G,
        Speed::_10G,
        Speed::_40G,
        Speed::_100G,
    ];
    for s in speeds {
        println!("  {:?}", s);
    }

    // Demonstrate address type choice (IPv4)
    println!("\nAddress type choice - IPv4:");
    let ipv4_config = InterfaceConfig {
        enabled: Some(true),
        mtu: None,
        address_type: Some(AddressType::Ipv4 {
            ipv4_address: "192.168.1.100/24".to_string(),
        }),
        speed: None,
        duplex: None,
    };
    println!("  {:?}", ipv4_config.address_type);

    // Demonstrate address type choice (IPv6)
    println!("\nAddress type choice - IPv6:");
    let ipv6_config = InterfaceConfig {
        enabled: Some(true),
        mtu: None,
        address_type: Some(AddressType::Ipv6 {
            ipv6_address: "2001:db8::1/64".to_string(),
        }),
        speed: None,
        duplex: None,
    };
    println!("  {:?}", ipv6_config.address_type);

    // Demonstrate serialization of choice variants
    println!("\nSerialized IPv4 choice:");
    let json = serde_json::to_string_pretty(&ipv4_config).expect("Serialization should succeed");
    println!("{}", json);

    println!("\nSerialized IPv6 choice:");
    let json = serde_json::to_string_pretty(&ipv6_config).expect("Serialization should succeed");
    println!("{}", json);
    println!();
}
