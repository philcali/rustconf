//! Server handler trait generation module.
//!
//! This module generates handler traits that define the server-side API surface
//! from YANG schemas. Each YANG module generates one handler trait with async
//! methods for each YANG operation (RPCs and data node CRUD operations).

use crate::generator::{GeneratorConfig, GeneratorError};
use crate::parser::{DataNode, Rpc, YangModule};

/// Generator for server handler traits.
#[allow(dead_code)]
pub struct ServerHandlerGenerator<'a> {
    config: &'a GeneratorConfig,
}

#[allow(dead_code)]
impl<'a> ServerHandlerGenerator<'a> {
    /// Create a new server handler generator with the given configuration.
    pub fn new(config: &'a GeneratorConfig) -> Self {
        Self { config }
    }

    /// Generate the handler trait for a YANG module.
    ///
    /// This creates a trait with async methods for:
    /// - Each YANG RPC operation
    /// - CRUD operations for each data node (based on config flag)
    pub fn generate_handler_trait(&self, module: &YangModule) -> Result<String, GeneratorError> {
        let mut output = String::new();

        // Generate file header
        output.push_str("// This file is automatically generated by rustconf.\n");
        output.push_str("// DO NOT EDIT MANUALLY.\n\n");

        // Add use statements
        output.push_str("use async_trait::async_trait;\n");
        output.push_str("use rustconf_runtime::ServerError;\n");
        output.push_str("use super::types::*;\n");
        output.push('\n');

        // Generate trait name from module name
        let trait_name = self.generate_trait_name(module);

        // Generate trait documentation
        output.push_str(&format!(
            "/// Handler trait for {} YANG module operations.\n",
            module.name
        ));
        output.push_str("///\n");
        output.push_str(
            "/// This trait defines the server-side API surface for RESTCONF operations.\n",
        );
        output.push_str(
            "/// Implement this trait to provide custom handler logic, or use the generated\n",
        );
        output.push_str("/// stub implementation for testing.\n");

        // Generate trait definition
        output.push_str("#[async_trait]\n");
        output.push_str(&format!("pub trait {}: Send + Sync {{\n", trait_name));

        // Generate methods for RPC operations
        for rpc in &module.rpcs {
            output.push_str(&self.generate_rpc_handler_method(rpc, module)?);
            output.push('\n');
        }

        // Generate methods for data node CRUD operations
        for node in &module.data_nodes {
            output.push_str(&self.generate_data_node_handler_methods(node, module)?);
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Generate the trait name from the module name.
    fn generate_trait_name(&self, module: &YangModule) -> String {
        let module_type_name = crate::generator::naming::to_type_name(&module.name);
        format!("{}Handler", module_type_name)
    }

    /// Generate a handler method for an RPC operation.
    fn generate_rpc_handler_method(
        &self,
        rpc: &Rpc,
        _module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();

        // Generate method documentation
        if let Some(ref description) = rpc.description {
            output.push_str(&self.generate_rustdoc(description));
        } else {
            output.push_str(&format!("    /// Execute {} RPC operation.\n", rpc.name));
        }

        // Generate method signature
        let method_name = crate::generator::naming::to_field_name(&rpc.name);
        let rpc_type_name = crate::generator::naming::to_type_name(&rpc.name);

        output.push_str("    async fn ");
        output.push_str(&method_name);
        output.push('(');

        // Add self parameter
        output.push_str("&self");

        // Add input parameter if RPC has input
        let has_input = rpc.input.as_ref().is_some_and(|nodes| !nodes.is_empty());
        if has_input {
            output.push_str(", input: ");
            output.push_str(&format!("{}Input", rpc_type_name));
        }

        output.push_str(") -> Result<");

        // Determine return type based on output
        let has_output = rpc.output.as_ref().is_some_and(|nodes| !nodes.is_empty());
        if has_output {
            output.push_str(&format!("{}Output", rpc_type_name));
        } else {
            output.push_str("()");
        }

        output.push_str(", ServerError>;");

        Ok(output)
    }

    /// Generate handler methods for a data node.
    fn generate_data_node_handler_methods(
        &self,
        node: &DataNode,
        module: &YangModule,
    ) -> Result<String, GeneratorError> {
        match node {
            DataNode::Container(container) => {
                self.generate_container_handler_methods(container, module)
            }
            DataNode::List(list) => self.generate_list_handler_methods(list, module),
            _ => Ok(String::new()), // Other node types don't generate handler methods
        }
    }

    /// Generate handler methods for a container.
    fn generate_container_handler_methods(
        &self,
        container: &crate::parser::Container,
        _module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();
        let type_name = crate::generator::naming::to_type_name(&container.name);
        let method_prefix = crate::generator::naming::to_field_name(&container.name);

        // Generate GET method (always available)
        output.push_str(&self.generate_method_doc(
            "GET",
            &format!("the {} container", container.name),
            container.description.as_deref(),
        ));
        output.push_str(&format!(
            "    async fn get_{}(&self) -> Result<{}, ServerError>;\n\n",
            method_prefix, type_name
        ));

        // Generate config-based methods (PUT, PATCH, DELETE) only if config is true
        if container.config {
            // PUT method
            output.push_str(&self.generate_method_doc(
                "PUT",
                &format!("the {} container", container.name),
                None,
            ));
            output.push_str(&format!(
                "    async fn put_{}(&self, data: {}) -> Result<(), ServerError>;\n\n",
                method_prefix, type_name
            ));

            // PATCH method
            output.push_str(&self.generate_method_doc(
                "PATCH",
                &format!("the {} container", container.name),
                None,
            ));
            output.push_str(&format!(
                "    async fn patch_{}(&self, data: {}) -> Result<(), ServerError>;\n\n",
                method_prefix, type_name
            ));

            // DELETE method
            output.push_str(&self.generate_method_doc(
                "DELETE",
                &format!("the {} container", container.name),
                None,
            ));
            output.push_str(&format!(
                "    async fn delete_{}(&self) -> Result<(), ServerError>;\n\n",
                method_prefix
            ));
        }

        Ok(output)
    }

    /// Generate handler methods for a list.
    fn generate_list_handler_methods(
        &self,
        list: &crate::parser::List,
        _module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();
        let type_name = crate::generator::naming::to_type_name(&list.name);
        let method_prefix = crate::generator::naming::to_field_name(&list.name);

        // Determine item type name (singular)
        let item_type_name = if type_name.ends_with('s') && type_name.len() > 1 {
            type_name[..type_name.len() - 1].to_string()
        } else {
            type_name.clone()
        };

        // Generate key parameters
        let key_params = self.generate_list_key_params(list);

        // GET method for entire list (collection)
        output.push_str(&self.generate_method_doc(
            "GET",
            &format!("all {} items", list.name),
            list.description.as_deref(),
        ));
        output.push_str(&format!(
            "    async fn get_{}(&self) -> Result<Vec<{}>, ServerError>;\n\n",
            method_prefix, item_type_name
        ));

        // GET method for single item by key
        output.push_str(&self.generate_method_doc(
            "GET",
            &format!("a single {} item by key", list.name),
            None,
        ));
        output.push_str(&format!(
            "    async fn get_{}_by_key(&self, {}) -> Result<{}, ServerError>;\n\n",
            method_prefix, key_params, item_type_name
        ));

        // Generate config-based methods only if config is true
        if list.config {
            // POST method - create new item
            output.push_str(&self.generate_method_doc(
                "POST",
                &format!("a new {} item", list.name),
                None,
            ));
            output.push_str(&format!(
                "    async fn create_{}(&self, data: {}) -> Result<(), ServerError>;\n\n",
                method_prefix, item_type_name
            ));

            // PUT method - replace item by key
            output.push_str(&self.generate_method_doc(
                "PUT",
                &format!("a {} item by key", list.name),
                None,
            ));
            output.push_str(&format!(
                "    async fn put_{}(&self, {}, data: {}) -> Result<(), ServerError>;\n\n",
                method_prefix, key_params, item_type_name
            ));

            // PATCH method - partial update by key
            output.push_str(&self.generate_method_doc(
                "PATCH",
                &format!("a {} item by key", list.name),
                None,
            ));
            output.push_str(&format!(
                "    async fn patch_{}(&self, {}, data: {}) -> Result<(), ServerError>;\n\n",
                method_prefix, key_params, item_type_name
            ));

            // DELETE method - remove item by key
            output.push_str(&self.generate_method_doc(
                "DELETE",
                &format!("a {} item by key", list.name),
                None,
            ));
            output.push_str(&format!(
                "    async fn delete_{}(&self, {}) -> Result<(), ServerError>;\n\n",
                method_prefix, key_params
            ));
        }

        Ok(output)
    }

    /// Generate key parameters for list operations.
    fn generate_list_key_params(&self, list: &crate::parser::List) -> String {
        let mut params = Vec::new();

        for key_name in &list.keys {
            // Find the leaf node for this key to determine its type
            let key_type = self.find_key_type(key_name, &list.children);
            let param_name = crate::generator::naming::to_field_name(key_name);
            params.push(format!("{}: {}", param_name, key_type));
        }

        params.join(", ")
    }

    /// Find the type of a key field in the list children.
    fn find_key_type(&self, key_name: &str, children: &[DataNode]) -> String {
        for child in children {
            if let DataNode::Leaf(leaf) = child {
                if leaf.name == key_name {
                    // Generate the type for this leaf (always mandatory for keys)
                    let type_gen = crate::generator::types::TypeGenerator::new(self.config);
                    return type_gen.generate_leaf_type(&leaf.type_spec, true);
                }
            }
        }

        // Default to String if key type not found
        "String".to_string()
    }

    /// Generate method documentation.
    fn generate_method_doc(
        &self,
        operation: &str,
        resource: &str,
        description: Option<&str>,
    ) -> String {
        let mut doc = String::new();

        if let Some(desc) = description {
            doc.push_str(&self.generate_rustdoc(desc));
            doc.push_str("    ///\n");
        }

        doc.push_str(&format!(
            "    /// {} operation for {}.\n",
            operation, resource
        ));
        doc
    }

    /// Generate rustdoc comments from a YANG description.
    fn generate_rustdoc(&self, description: &str) -> String {
        let mut rustdoc = String::new();

        for line in description.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() {
                rustdoc.push_str("    ///\n");
            } else {
                rustdoc.push_str(&format!("    /// {}\n", trimmed));
            }
        }

        rustdoc
    }
}
