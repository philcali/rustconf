//! Server request router generation module.
//!
//! This module generates request routing logic that maps incoming RESTCONF
//! requests to appropriate handler methods based on URL path and HTTP method.

use crate::generator::{GeneratorConfig, GeneratorError};
use crate::parser::{DataNode, YangModule};

/// Generator for server request router.
#[allow(dead_code)]
pub struct RouterGenerator<'a> {
    config: &'a GeneratorConfig,
}

#[allow(dead_code)]
impl<'a> RouterGenerator<'a> {
    /// Create a new router generator with the given configuration.
    pub fn new(config: &'a GeneratorConfig) -> Self {
        Self { config }
    }

    /// Generate the router implementation for a YANG module.
    ///
    /// This creates a RestconfRouter struct that routes incoming requests
    /// to the appropriate handler methods based on path and HTTP method.
    pub fn generate_router(&self, module: &YangModule) -> Result<String, GeneratorError> {
        let mut output = String::new();

        // Generate file header
        output.push_str("// This file is automatically generated by rustconf.\n");
        output.push_str("// DO NOT EDIT MANUALLY.\n\n");

        // Add use statements
        output.push_str("use async_trait::async_trait;\n");
        output.push_str(
            "use rustconf_runtime::{ServerRequest, ServerResponse, ServerError, HttpMethod};\n",
        );
        output.push_str("use std::sync::Arc;\n");
        output.push_str("use serde_json;\n");
        output.push_str("use super::handlers::*;\n");
        output.push_str("use super::types::*;\n");
        output.push('\n');

        // Generate router struct
        let trait_name = self.generate_trait_name(module);
        output.push_str(&format!(
            "/// Request router for {} YANG module.\n",
            module.name
        ));
        output.push_str("///\n");
        output.push_str("/// Routes incoming RESTCONF requests to appropriate handler methods\n");
        output.push_str("/// based on URL path and HTTP method.\n");
        output.push_str(&format!(
            "pub struct RestconfRouter<H: {}> {{\n",
            trait_name
        ));
        output.push_str("    /// The handler implementation\n");
        output.push_str("    handler: Arc<H>,\n");
        output.push_str("    /// Base path for RESTCONF operations (e.g., \"/restconf\")\n");
        output.push_str("    base_path: String,\n");
        output.push_str("}\n\n");

        // Generate router implementation
        output.push_str(&format!("impl<H: {}> RestconfRouter<H> {{\n", trait_name));

        // Constructor
        output.push_str("    /// Create a new router with the given handler.\n");
        output.push_str("    ///\n");
        output.push_str("    /// # Arguments\n");
        output.push_str("    ///\n");
        output.push_str("    /// * `handler` - The handler implementation\n");
        output.push_str(
            "    /// * `base_path` - Base path for RESTCONF operations (e.g., \"/restconf\")\n",
        );
        output.push_str("    pub fn new(handler: H, base_path: impl Into<String>) -> Self {\n");
        output.push_str("        Self {\n");
        output.push_str("            handler: Arc::new(handler),\n");
        output.push_str("            base_path: base_path.into(),\n");
        output.push_str("        }\n");
        output.push_str("    }\n\n");

        // Route method
        output.push_str("    /// Route an incoming request to the appropriate handler.\n");
        output.push_str("    ///\n");
        output.push_str("    /// This method:\n");
        output.push_str(
            "    /// 1. Parses the request path and matches it against YANG-defined paths\n",
        );
        output.push_str("    /// 2. Deserializes the request body if needed\n");
        output.push_str("    /// 3. Invokes the appropriate handler method\n");
        output.push_str("    /// 4. Serializes the response\n");
        output.push_str("    /// 5. Handles errors appropriately\n");
        output.push_str(
            "    pub async fn route(&self, request: ServerRequest) -> ServerResponse {\n",
        );
        output.push_str("        // Strip base path from request path\n");
        output.push_str("        let path = if let Some(stripped) = request.path.strip_prefix(&self.base_path) {\n");
        output.push_str("            stripped\n");
        output.push_str("        } else {\n");
        output.push_str("            return ServerResponse::from_error(\n");
        output.push_str("                ServerError::NotFound(format!(\n");
        output.push_str("                    \"Path does not start with base path: {}\",\n");
        output.push_str("                    self.base_path\n");
        output.push_str("                ))\n");
        output.push_str("            );\n");
        output.push_str("        };\n\n");
        output.push_str("        // Parse path segments\n");
        output.push_str("        let segments: Vec<&str> = path\n");
        output.push_str("            .trim_start_matches('/')\n");
        output.push_str("            .split('/')\n");
        output.push_str("            .filter(|s| !s.is_empty())\n");
        output.push_str("            .collect();\n\n");
        output.push_str("        // Match path and route to handler\n");
        output.push_str("        self.match_and_route(&segments, &request).await\n");
        output.push_str("    }\n\n");

        // Add helper methods for routing
        output.push_str(
            "    /// Match path segments against YANG-defined paths and route to handler.\n",
        );
        output.push_str("    async fn match_and_route(\n");
        output.push_str("        &self,\n");
        output.push_str("        segments: &[&str],\n");
        output.push_str("        request: &ServerRequest,\n");
        output.push_str("    ) -> ServerResponse {\n");
        output
            .push_str("        // Check for RPC operations first (path: /operations/<rpc-name>)\n");
        output.push_str("        if segments.len() >= 2 && segments[0] == \"operations\" {\n");
        output.push_str("            return self.route_rpc(segments[1], request).await;\n");
        output.push_str("        }\n\n");
        output.push_str("        // Check for data operations (path: /data/<path>)\n");
        output.push_str("        if segments.len() >= 2 && segments[0] == \"data\" {\n");
        output.push_str("            return self.route_data(&segments[1..], request).await;\n");
        output.push_str("        }\n\n");
        output.push_str("        // Path not found\n");
        output.push_str("        ServerResponse::from_error(\n");
        output.push_str("            ServerError::NotFound(format!(\"Unknown path: /{}\", segments.join(\"/\")))\n");
        output.push_str("        )\n");
        output.push_str("    }\n\n");

        // Generate RPC routing with actual dispatch
        output.push_str(&self.generate_rpc_routing(module)?);

        // Generate data routing with actual dispatch
        output.push_str(&self.generate_data_routing(module)?);

        // Add percent decoding helper
        output.push_str("    /// Decode percent-encoded URL component.\n");
        output.push_str("    fn percent_decode(s: &str) -> Result<String, ServerError> {\n");
        output.push_str("        // Simple percent decoding implementation\n");
        output.push_str("        let mut result = String::new();\n");
        output.push_str("        let mut chars = s.chars().peekable();\n\n");
        output.push_str("        while let Some(ch) = chars.next() {\n");
        output.push_str("            if ch == '%' {\n");
        output.push_str("                // Read next two characters as hex digits\n");
        output.push_str("                let hex: String = chars.by_ref().take(2).collect();\n");
        output.push_str("                if hex.len() != 2 {\n");
        output.push_str("                    return Err(ServerError::DeserializationError(\n");
        output
            .push_str("                        format!(\"Invalid percent encoding: %{}\", hex)\n");
        output.push_str("                    ));\n");
        output.push_str("                }\n\n");
        output.push_str("                match u8::from_str_radix(&hex, 16) {\n");
        output.push_str("                    Ok(byte) => {\n");
        output.push_str("                        // Convert byte to char\n");
        output.push_str("                        if byte < 128 {\n");
        output.push_str("                            result.push(byte as char);\n");
        output.push_str("                        } else {\n");
        output.push_str(
            "                            return Err(ServerError::DeserializationError(\n",
        );
        output.push_str("                                format!(\"Invalid UTF-8 in percent encoding: %{}\", hex)\n");
        output.push_str("                            ));\n");
        output.push_str("                        }\n");
        output.push_str("                    }\n");
        output.push_str("                    Err(_) => {\n");
        output.push_str("                        return Err(ServerError::DeserializationError(\n");
        output.push_str(
            "                            format!(\"Invalid hex in percent encoding: %{}\", hex)\n",
        );
        output.push_str("                        ));\n");
        output.push_str("                    }\n");
        output.push_str("                }\n");
        output.push_str("            } else {\n");
        output.push_str("                result.push(ch);\n");
        output.push_str("            }\n");
        output.push_str("        }\n\n");
        output.push_str("        Ok(result)\n");
        output.push_str("    }\n\n");

        // Add deserialization helper
        output.push_str("    /// Deserialize request body as JSON.\n");
        output.push_str("    fn deserialize_body<T: serde::de::DeserializeOwned>(\n");
        output.push_str("        request: &ServerRequest,\n");
        output.push_str("    ) -> Result<T, ServerError> {\n");
        output.push_str("        // Check if body exists\n");
        output.push_str("        let body = request.body.as_ref().ok_or_else(|| {\n");
        output.push_str("            ServerError::DeserializationError(\"Request body is required\".to_string())\n");
        output.push_str("        })?;\n\n");
        output.push_str("        // Deserialize JSON\n");
        output.push_str("        serde_json::from_slice(body).map_err(|e| {\n");
        output.push_str("            ServerError::DeserializationError(format!(\n");
        output.push_str("                \"Failed to deserialize request body: {}\",\n");
        output.push_str("                e\n");
        output.push_str("            ))\n");
        output.push_str("        })\n");
        output.push_str("    }\n\n");

        // Add serialization helper
        output.push_str("    /// Serialize response data as JSON.\n");
        output.push_str("    fn serialize_response<T: serde::Serialize>(\n");
        output.push_str("        data: T,\n");
        output.push_str("    ) -> Result<ServerResponse, ServerError> {\n");
        output.push_str("        let body = serde_json::to_vec(&data).map_err(|e| {\n");
        output.push_str("            ServerError::SerializationError(format!(\n");
        output.push_str("                \"Failed to serialize response: {}\",\n");
        output.push_str("                e\n");
        output.push_str("            ))\n");
        output.push_str("        })?;\n\n");
        output.push_str("        Ok(ServerResponse::json(200, body))\n");
        output.push_str("    }\n");
        output.push_str("}\n");

        Ok(output)
    }

    /// Generate the trait name from the module name.
    fn generate_trait_name(&self, module: &YangModule) -> String {
        let module_type_name = crate::generator::naming::to_type_name(&module.name);
        format!("{}Handler", module_type_name)
    }

    /// Generate RPC routing logic with handler dispatch.
    fn generate_rpc_routing(&self, module: &YangModule) -> Result<String, GeneratorError> {
        let mut output = String::new();

        output.push_str("    /// Route RPC operation requests.\n");
        output.push_str("    async fn route_rpc(&self, rpc_name: &str, request: &ServerRequest) -> ServerResponse {\n");
        output.push_str("        // Decode percent-encoded RPC name\n");
        output.push_str("        let rpc_name = match Self::percent_decode(rpc_name) {\n");
        output.push_str("            Ok(name) => name,\n");
        output.push_str("            Err(e) => return ServerResponse::from_error(e),\n");
        output.push_str("        };\n\n");

        // Generate match statement for each RPC
        if !module.rpcs.is_empty() {
            output.push_str("        // Match RPC name and dispatch to handler\n");
            output.push_str("        match rpc_name.as_str() {\n");

            for rpc in &module.rpcs {
                let method_name = crate::generator::naming::to_field_name(&rpc.name);
                let rpc_type_name = crate::generator::naming::to_type_name(&rpc.name);
                let has_input = rpc.input.as_ref().is_some_and(|nodes| !nodes.is_empty());
                let has_output = rpc.output.as_ref().is_some_and(|nodes| !nodes.is_empty());

                output.push_str(&format!("            \"{}\" => {{\n", rpc.name));

                // Deserialize input if needed
                if has_input {
                    output.push_str(&format!(
                        "                let input: {}Input = match Self::deserialize_body(request) {{\n",
                        rpc_type_name
                    ));
                    output.push_str("                    Ok(data) => data,\n");
                    output.push_str(
                        "                    Err(e) => return ServerResponse::from_error(e),\n",
                    );
                    output.push_str("                };\n\n");

                    // Call handler with input
                    output.push_str(&format!(
                        "                match self.handler.{}(input).await {{\n",
                        method_name
                    ));
                } else {
                    // Call handler without input
                    output.push_str(&format!(
                        "                match self.handler.{}().await {{\n",
                        method_name
                    ));
                }

                // Handle response
                if has_output {
                    output.push_str("                    Ok(output) => {\n");
                    output.push_str(
                        "                        match Self::serialize_response(output) {\n",
                    );
                    output.push_str("                            Ok(response) => response,\n");
                    output.push_str(
                        "                            Err(e) => ServerResponse::from_error(e),\n",
                    );
                    output.push_str("                        }\n");
                    output.push_str("                    }\n");
                } else {
                    output.push_str("                    Ok(()) => ServerResponse::new(204),\n");
                }

                output.push_str("                    Err(e) => ServerResponse::from_error(e),\n");
                output.push_str("                }\n");
                output.push_str("            }\n");
            }

            output.push_str("            _ => ServerResponse::from_error(\n");
            output.push_str("                ServerError::NotFound(format!(\"RPC operation not found: {}\", rpc_name))\n");
            output.push_str("            ),\n");
            output.push_str("        }\n");
        } else {
            output.push_str("        // No RPC operations defined\n");
            output.push_str("        ServerResponse::from_error(\n");
            output.push_str("            ServerError::NotFound(format!(\"RPC operation not found: {}\", rpc_name))\n");
            output.push_str("        )\n");
        }

        output.push_str("    }\n\n");

        Ok(output)
    }

    /// Generate data routing logic with handler dispatch.
    fn generate_data_routing(&self, module: &YangModule) -> Result<String, GeneratorError> {
        let mut output = String::new();

        output.push_str("    /// Route data operation requests.\n");
        output.push_str("    async fn route_data(&self, segments: &[&str], request: &ServerRequest) -> ServerResponse {\n");
        output.push_str("        // Decode percent-encoded path segments\n");
        output.push_str(
            "        let decoded_segments: Result<Vec<String>, ServerError> = segments\n",
        );
        output.push_str("            .iter()\n");
        output.push_str("            .map(|s| Self::percent_decode(s))\n");
        output.push_str("            .collect();\n\n");
        output.push_str("        let decoded_segments = match decoded_segments {\n");
        output.push_str("            Ok(segs) => segs,\n");
        output.push_str("            Err(e) => return ServerResponse::from_error(e),\n");
        output.push_str("        };\n\n");

        // Generate routing for data nodes
        if !module.data_nodes.is_empty() {
            output.push_str("        // Match data path and dispatch to handler\n");
            output.push_str("        if decoded_segments.is_empty() {\n");
            output.push_str("            return ServerResponse::from_error(\n");
            output.push_str(
                "                ServerError::NotFound(\"Empty data path\".to_string())\n",
            );
            output.push_str("            );\n");
            output.push_str("        }\n\n");

            output.push_str("        // Match first segment against top-level data nodes\n");
            output.push_str("        match decoded_segments[0].as_str() {\n");

            for node in &module.data_nodes {
                match node {
                    DataNode::Container(container) => {
                        output.push_str(&self.generate_container_routing(container)?);
                    }
                    DataNode::List(list) => {
                        output.push_str(&self.generate_list_routing(list)?);
                    }
                    _ => {}
                }
            }

            output.push_str("            _ => ServerResponse::from_error(\n");
            output.push_str("                ServerError::NotFound(format!(\"Data path not found: /{}\", decoded_segments.join(\"/\")))\n");
            output.push_str("            ),\n");
            output.push_str("        }\n");
        } else {
            output.push_str("        // No data nodes defined\n");
            output.push_str("        ServerResponse::from_error(\n");
            output.push_str("            ServerError::NotFound(format!(\"Data path not found: /{}\", decoded_segments.join(\"/\")))\n");
            output.push_str("        )\n");
        }

        output.push_str("    }\n\n");

        Ok(output)
    }

    /// Generate routing for a container node.
    fn generate_container_routing(
        &self,
        container: &crate::parser::Container,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();
        let method_prefix = crate::generator::naming::to_field_name(&container.name);
        let type_name = crate::generator::naming::to_type_name(&container.name);

        output.push_str(&format!("            \"{}\" => {{\n", container.name));
        output.push_str("                // Container operations\n");
        output.push_str("                if decoded_segments.len() != 1 {\n");
        output.push_str("                    return ServerResponse::from_error(\n");
        output.push_str("                        ServerError::NotFound(\"Invalid path depth for container\".to_string())\n");
        output.push_str("                    );\n");
        output.push_str("                }\n\n");

        output.push_str("                match request.method {\n");

        // GET method (always available)
        output.push_str("                    HttpMethod::GET => {\n");
        output.push_str(&format!(
            "                        match self.handler.get_{}().await {{\n",
            method_prefix
        ));
        output.push_str("                            Ok(data) => {\n");
        output.push_str("                                match Self::serialize_response(data) {\n");
        output.push_str("                                    Ok(response) => response,\n");
        output.push_str(
            "                                    Err(e) => ServerResponse::from_error(e),\n",
        );
        output.push_str("                                }\n");
        output.push_str("                            }\n");
        output.push_str("                            Err(e) => ServerResponse::from_error(e),\n");
        output.push_str("                        }\n");
        output.push_str("                    }\n");

        // Config-based methods
        if container.config {
            // PUT method
            output.push_str("                    HttpMethod::PUT => {\n");
            output.push_str(&format!(
                "                        let data: {} = match Self::deserialize_body(request) {{\n",
                type_name
            ));
            output.push_str("                            Ok(d) => d,\n");
            output.push_str(
                "                            Err(e) => return ServerResponse::from_error(e),\n",
            );
            output.push_str("                        };\n");
            output.push_str(&format!(
                "                        match self.handler.put_{}(data).await {{\n",
                method_prefix
            ));
            output.push_str("                            Ok(()) => ServerResponse::new(204),\n");
            output
                .push_str("                            Err(e) => ServerResponse::from_error(e),\n");
            output.push_str("                        }\n");
            output.push_str("                    }\n");

            // PATCH method
            output.push_str("                    HttpMethod::PATCH => {\n");
            output.push_str(&format!(
                "                        let data: {} = match Self::deserialize_body(request) {{\n",
                type_name
            ));
            output.push_str("                            Ok(d) => d,\n");
            output.push_str(
                "                            Err(e) => return ServerResponse::from_error(e),\n",
            );
            output.push_str("                        };\n");
            output.push_str(&format!(
                "                        match self.handler.patch_{}(data).await {{\n",
                method_prefix
            ));
            output.push_str("                            Ok(()) => ServerResponse::new(204),\n");
            output
                .push_str("                            Err(e) => ServerResponse::from_error(e),\n");
            output.push_str("                        }\n");
            output.push_str("                    }\n");

            // DELETE method
            output.push_str("                    HttpMethod::DELETE => {\n");
            output.push_str(&format!(
                "                        match self.handler.delete_{}().await {{\n",
                method_prefix
            ));
            output.push_str("                            Ok(()) => ServerResponse::new(204),\n");
            output
                .push_str("                            Err(e) => ServerResponse::from_error(e),\n");
            output.push_str("                        }\n");
            output.push_str("                    }\n");
        }

        output.push_str("                    _ => ServerResponse::from_error(\n");
        output.push_str(
            "                        ServerError::NotFound(\"Method not allowed\".to_string())\n",
        );
        output.push_str("                    ),\n");
        output.push_str("                }\n");
        output.push_str("            }\n");

        Ok(output)
    }

    /// Generate routing for a list node.
    fn generate_list_routing(&self, list: &crate::parser::List) -> Result<String, GeneratorError> {
        let mut output = String::new();
        let method_prefix = crate::generator::naming::to_field_name(&list.name);
        let type_name = crate::generator::naming::to_type_name(&list.name);

        // Determine item type name (singular)
        let _item_type_name = if type_name.ends_with('s') && type_name.len() > 1 {
            type_name[..type_name.len() - 1].to_string()
        } else {
            type_name.clone()
        };

        output.push_str(&format!("            \"{}\" => {{\n", list.name));
        output.push_str("                // List operations\n");
        output.push_str("                // TODO: Implement list key extraction and routing\n");
        output.push_str("                // For now, only support collection-level GET\n");
        output.push_str("                if decoded_segments.len() == 1 && request.method == HttpMethod::GET {\n");
        output.push_str(&format!(
            "                    match self.handler.get_{}().await {{\n",
            method_prefix
        ));
        output.push_str("                        Ok(data) => {\n");
        output.push_str("                            match Self::serialize_response(data) {\n");
        output.push_str("                                Ok(response) => response,\n");
        output
            .push_str("                                Err(e) => ServerResponse::from_error(e),\n");
        output.push_str("                            }\n");
        output.push_str("                        }\n");
        output.push_str("                        Err(e) => ServerResponse::from_error(e),\n");
        output.push_str("                    }\n");
        output.push_str("                } else {\n");
        output.push_str("                    ServerResponse::from_error(\n");
        output.push_str("                        ServerError::NotFound(\"List item operations not yet implemented\".to_string())\n");
        output.push_str("                    )\n");
        output.push_str("                }\n");
        output.push_str("            }\n");

        Ok(output)
    }
}
