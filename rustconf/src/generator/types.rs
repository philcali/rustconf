//! Type generation module for YANG data nodes.
//!
//! This module handles the generation of Rust types (structs, enums, type aliases)
//! from YANG data definitions including containers, lists, choices, and typedefs.

use crate::generator::{GeneratorConfig, GeneratorError};
use crate::parser::{Case, Choice, Container, DataNode, List, TypeDef, YangModule};

/// Generator for Rust type definitions from YANG data nodes.
pub struct TypeGenerator<'a> {
    config: &'a GeneratorConfig,
}

impl<'a> TypeGenerator<'a> {
    /// Create a new type generator with the given configuration.
    pub fn new(config: &'a GeneratorConfig) -> Self {
        Self { config }
    }
}

impl<'a> TypeGenerator<'a> {
    /// Generate a Rust type alias from a YANG typedef.
    pub fn generate_typedef(&self, typedef: &TypeDef) -> Result<String, GeneratorError> {
        use crate::generator::formatting;
        use crate::parser::TypeSpec;

        let type_name = crate::generator::naming::to_type_name(&typedef.name);

        // Check if this typedef has constraints that require validation
        let needs_validation = self.config.enable_validation
            && matches!(
                &typedef.type_spec,
                TypeSpec::String {
                    length: Some(_),
                    ..
                } | TypeSpec::String {
                    pattern: Some(_),
                    ..
                } | TypeSpec::Int8 { range: Some(_) }
                    | TypeSpec::Int16 { range: Some(_) }
                    | TypeSpec::Int32 { range: Some(_) }
                    | TypeSpec::Int64 { range: Some(_) }
                    | TypeSpec::Uint8 { range: Some(_) }
                    | TypeSpec::Uint16 { range: Some(_) }
                    | TypeSpec::Uint32 { range: Some(_) }
                    | TypeSpec::Uint64 { range: Some(_) }
            );

        let target_type_str = if needs_validation {
            // Generate a validated type instead of a simple alias
            // The validated type will be generated by collect_validated_types
            // Just create a type alias to the validated type
            self.get_validated_type_name(&typedef.type_spec)
        } else {
            // Generate a simple type alias
            self.generate_leaf_type(&typedef.type_spec, true)
        };

        // Convert the type string to a syn::Type
        let target_type: syn::Type = syn::parse_str(&target_type_str)
            .map_err(|e| GeneratorError::CodeGeneration(format!("Failed to parse type '{}': {}", target_type_str, e)))?;

        // Use the formatting module to generate the type alias
        formatting::generate_type_alias(
            &type_name,
            target_type,
            typedef.description.as_deref(),
        )
        .map_err(|e| GeneratorError::CodeGeneration(format!("Failed to generate type alias: {}", e)))
    }

    /// Generate code for a data node.
    pub fn generate_data_node(
        &self,
        node: &DataNode,
        module: &YangModule,
    ) -> Result<String, GeneratorError> {
        match node {
            DataNode::Container(container) => self.generate_container(container, module),
            DataNode::List(list) => self.generate_list(list, module),
            DataNode::Leaf(_) => Ok(String::new()), // Leaves are handled as struct fields
            DataNode::LeafList(_) => Ok(String::new()), // Will be implemented later
            DataNode::Choice(choice) => self.generate_choice(choice, module),
            DataNode::Case(_) => Ok(String::new()), // Cases are handled within choices
            DataNode::Uses(_) => Ok(String::new()), // Uses should be expanded during parsing
        }
    }

    /// Generate a Rust struct from a YANG container.
    pub fn generate_container(
        &self,
        container: &Container,
        module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();

        // Generate rustdoc comment from YANG description
        if let Some(ref description) = container.description {
            output.push_str(&self.generate_rustdoc(description));
        }

        // Generate derive attributes
        output.push_str(&self.generate_derive_attributes());

        // Generate struct definition
        let type_name = crate::generator::naming::to_type_name(&container.name);
        output.push_str(&format!("pub struct {} {{\n", type_name));

        // Generate fields from child nodes
        for child in &container.children {
            output.push_str(&self.generate_field(child, module, None)?);
        }

        output.push_str("}\n");

        // Recursively generate types for nested containers, lists, and choices
        for child in &container.children {
            match child {
                DataNode::Container(nested) => {
                    output.push('\n');
                    output.push_str(&self.generate_container(nested, module)?);
                }
                DataNode::List(nested) => {
                    output.push('\n');
                    output.push_str(&self.generate_list(nested, module)?);
                }
                DataNode::Choice(nested) => {
                    output.push('\n');
                    output.push_str(&self.generate_choice(nested, module)?);
                }
                _ => {}
            }
        }

        Ok(output)
    }

    /// Generate a Rust enum from a YANG choice.
    pub fn generate_choice(
        &self,
        choice: &Choice,
        module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();

        // Generate rustdoc comment from YANG description
        if let Some(ref description) = choice.description {
            output.push_str(&self.generate_rustdoc(description));
        }

        // Generate derive attributes
        output.push_str(&self.generate_derive_attributes());

        // Add serde attribute for kebab-case serialization
        output.push_str("#[serde(rename_all = \"kebab-case\")]\n");

        // Generate enum definition
        let type_name = crate::generator::naming::to_type_name(&choice.name);
        output.push_str(&format!("pub enum {} {{\n", type_name));

        // Generate variants from cases
        for case in &choice.cases {
            // Add rustdoc comment for case if description exists
            if let Some(ref description) = case.description {
                output.push_str(&format!("    {}", self.generate_rustdoc(description)));
            }

            let variant_name = crate::generator::naming::to_type_name(&case.name);

            // Determine the variant type based on case contents
            if case.data_nodes.is_empty() {
                // Empty case - unit variant
                output.push_str(&format!("    {},\n", variant_name));
            } else if case.data_nodes.len() == 1 {
                // Single data node - check if it's a leaf or complex type
                match &case.data_nodes[0] {
                    DataNode::Leaf(leaf) => {
                        // Single leaf - use tuple variant with the leaf type
                        let leaf_type = self.generate_leaf_type(&leaf.type_spec, true);
                        output.push_str(&format!("    {}({}),\n", variant_name, leaf_type));
                    }
                    _ => {
                        // Complex type - use named struct variant
                        let case_type_name = format!("{}Data", variant_name);
                        output.push_str(&format!("    {}({}),\n", variant_name, case_type_name));
                    }
                }
            } else {
                // Multiple data nodes - use named struct variant
                let case_type_name = format!("{}Data", variant_name);
                output.push_str(&format!("    {}({}),\n", variant_name, case_type_name));
            }
        }

        output.push_str("}\n");

        // Generate struct types for cases with multiple or complex data nodes
        for case in &choice.cases {
            if case.data_nodes.len() > 1
                || (case.data_nodes.len() == 1 && !matches!(case.data_nodes[0], DataNode::Leaf(_)))
            {
                output.push('\n');
                output.push_str(&self.generate_case_struct(case, module)?);
            }
        }

        // Recursively generate types for nested containers and lists within cases
        for case in &choice.cases {
            for node in &case.data_nodes {
                match node {
                    DataNode::Container(nested) => {
                        output.push('\n');
                        output.push_str(&self.generate_container(nested, module)?);
                    }
                    DataNode::List(nested) => {
                        output.push('\n');
                        output.push_str(&self.generate_list(nested, module)?);
                    }
                    _ => {}
                }
            }
        }

        Ok(output)
    }

    /// Generate a struct for a case with multiple data nodes.
    pub fn generate_case_struct(
        &self,
        case: &Case,
        module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();

        // Generate rustdoc comment from case description
        if let Some(ref description) = case.description {
            output.push_str(&self.generate_rustdoc(description));
        }

        // Generate derive attributes
        output.push_str(&self.generate_derive_attributes());

        // Generate struct definition
        let variant_name = crate::generator::naming::to_type_name(&case.name);
        let struct_name = format!("{}Data", variant_name);
        output.push_str(&format!("pub struct {} {{\n", struct_name));

        // Generate fields from data nodes
        for node in &case.data_nodes {
            output.push_str(&self.generate_field(node, module, None)?);
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Generate a Rust struct and Vec type alias from a YANG list.
    pub fn generate_list(
        &self,
        list: &List,
        module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();

        // Generate rustdoc comment from YANG description
        if let Some(ref description) = list.description {
            output.push_str(&self.generate_rustdoc(description));
        }

        // Generate derive attributes
        output.push_str(&self.generate_derive_attributes());

        // Generate struct definition for list items
        let type_name = crate::generator::naming::to_type_name(&list.name);
        // Remove trailing 's' for singular item type name if present
        let item_type_name = if type_name.ends_with('s') && type_name.len() > 1 {
            &type_name[..type_name.len() - 1]
        } else {
            &type_name
        };

        output.push_str(&format!("pub struct {} {{\n", item_type_name));

        // Generate fields from child nodes
        // Key fields must be non-optional
        for child in &list.children {
            output.push_str(&self.generate_field(child, module, Some(&list.keys))?);
        }

        output.push_str("}\n\n");

        // Recursively generate types for nested containers, lists, and choices
        for child in &list.children {
            match child {
                DataNode::Container(nested) => {
                    output.push('\n');
                    output.push_str(&self.generate_container(nested, module)?);
                }
                DataNode::List(nested) => {
                    output.push('\n');
                    output.push_str(&self.generate_list(nested, module)?);
                }
                DataNode::Choice(nested) => {
                    output.push('\n');
                    output.push_str(&self.generate_choice(nested, module)?);
                }
                _ => {}
            }
        }

        Ok(output)
    }

    /// Generate a struct field from a data node.
    /// When keys are provided, key fields are forced to be mandatory (non-optional).
    pub fn generate_field(
        &self,
        node: &DataNode,
        module: &YangModule,
        keys: Option<&[String]>,
    ) -> Result<String, GeneratorError> {
        match node {
            DataNode::Leaf(leaf) => {
                let mut field = String::new();

                // Add rustdoc comment if description exists
                if let Some(ref description) = leaf.description {
                    field.push_str(&format!("    {}", self.generate_rustdoc(description)));
                }

                // Check if this leaf is a key field
                let is_key = keys.is_some_and(|k| k.contains(&leaf.name));

                // Build serde attributes
                let field_name_json = self.get_json_field_name(&leaf.name, module);
                let mut serde_attrs = vec![format!("rename = \"{}\"", field_name_json)];
                // Key fields are always mandatory, so only add skip_serializing_if for non-key optional fields
                if !is_key && !leaf.mandatory {
                    serde_attrs.push("skip_serializing_if = \"Option::is_none\"".to_string());
                }
                field.push_str(&format!("    #[serde({})]\n", serde_attrs.join(", ")));

                // Generate field name and type
                let field_name = crate::generator::naming::to_field_name(&leaf.name);
                // Key fields are always non-optional
                let field_type = if is_key {
                    self.generate_leaf_type(&leaf.type_spec, true)
                } else {
                    self.generate_leaf_type(&leaf.type_spec, leaf.mandatory)
                };
                field.push_str(&format!("    pub {}: {},\n", field_name, field_type));

                Ok(field)
            }
            DataNode::Container(container) => {
                let mut field = String::new();

                // Add rustdoc comment if description exists
                if let Some(ref description) = container.description {
                    field.push_str(&format!("    {}", self.generate_rustdoc(description)));
                }

                // Build serde attributes
                let field_name_json = self.get_json_field_name(&container.name, module);
                let mut serde_attrs = vec![format!("rename = \"{}\"", field_name_json)];
                if !container.mandatory {
                    serde_attrs.push("skip_serializing_if = \"Option::is_none\"".to_string());
                }
                field.push_str(&format!("    #[serde({})]\n", serde_attrs.join(", ")));

                // Generate field name and type
                let field_name = crate::generator::naming::to_field_name(&container.name);
                let type_name = crate::generator::naming::to_type_name(&container.name);
                let field_type = if container.mandatory {
                    type_name
                } else {
                    format!("Option<{}>", type_name)
                };
                field.push_str(&format!("    pub {}: {},\n", field_name, field_type));

                Ok(field)
            }
            DataNode::List(list) => {
                let mut field = String::new();

                // Add rustdoc comment if description exists
                if let Some(ref description) = list.description {
                    field.push_str(&format!("    {}", self.generate_rustdoc(description)));
                }

                // Build serde attributes
                let field_name_json = self.get_json_field_name(&list.name, module);
                field.push_str(&format!("    #[serde(rename = \"{}\")]\n", field_name_json));

                // Generate field name and type
                let field_name = crate::generator::naming::to_field_name(&list.name);
                let type_name = crate::generator::naming::to_type_name(&list.name);
                // Determine item type name (singular)
                let item_type_name = if type_name.ends_with('s') && type_name.len() > 1 {
                    &type_name[..type_name.len() - 1]
                } else {
                    &type_name
                };
                // Lists are always collections (Vec)
                field.push_str(&format!(
                    "    pub {}: Vec<{}>,\n",
                    field_name, item_type_name
                ));

                Ok(field)
            }
            DataNode::LeafList(_) => Ok(String::new()), // Will be implemented later
            DataNode::Choice(choice) => {
                let mut field = String::new();

                // Add rustdoc comment if description exists
                if let Some(ref description) = choice.description {
                    field.push_str(&format!("    {}", self.generate_rustdoc(description)));
                }

                // Build serde attributes
                let field_name_json = self.get_json_field_name(&choice.name, module);
                let mut serde_attrs = vec![format!("rename = \"{}\"", field_name_json)];
                if !choice.mandatory {
                    serde_attrs.push("skip_serializing_if = \"Option::is_none\"".to_string());
                }
                field.push_str(&format!("    #[serde({})]\n", serde_attrs.join(", ")));

                // Generate field name and type
                let field_name = crate::generator::naming::to_field_name(&choice.name);
                let type_name = crate::generator::naming::to_type_name(&choice.name);
                let field_type = if choice.mandatory {
                    type_name
                } else {
                    format!("Option<{}>", type_name)
                };
                field.push_str(&format!("    pub {}: {},\n", field_name, field_type));

                Ok(field)
            }
            DataNode::Case(_) => Ok(String::new()), // Cases are handled within choices
            DataNode::Uses(_) => Ok(String::new()), // Uses should be expanded during parsing
        }
    }

    /// Generate a Rust type from a YANG leaf type specification.
    pub fn generate_leaf_type(
        &self,
        type_spec: &crate::parser::TypeSpec,
        mandatory: bool,
    ) -> String {
        use crate::parser::TypeSpec;

        // Check if we should generate a validated type
        if self.config.enable_validation && self.needs_validation(type_spec) {
            let validated_type_name = self.get_validated_type_name(type_spec);
            if mandatory {
                return validated_type_name;
            } else {
                return format!("Option<{}>", validated_type_name);
            }
        }

        let base_type = match type_spec {
            TypeSpec::Int8 { .. } => "i8",
            TypeSpec::Int16 { .. } => "i16",
            TypeSpec::Int32 { .. } => "i32",
            TypeSpec::Int64 { .. } => "i64",
            TypeSpec::Uint8 { .. } => "u8",
            TypeSpec::Uint16 { .. } => "u16",
            TypeSpec::Uint32 { .. } => "u32",
            TypeSpec::Uint64 { .. } => "u64",
            TypeSpec::String { .. } => "String",
            TypeSpec::Boolean => "bool",
            TypeSpec::Empty => "()",
            TypeSpec::Binary { .. } => "Vec<u8>",
            TypeSpec::Enumeration { .. } => "String", // Will be improved in later tasks
            TypeSpec::Union { .. } => "String",       // Will be improved in later tasks
            TypeSpec::LeafRef { .. } => "String",     // Will be improved in later tasks
            TypeSpec::TypedefRef { name } => {
                // Use the typedef name as the type
                &crate::generator::naming::to_type_name(name)
            }
        };

        if mandatory {
            base_type.to_string()
        } else {
            format!("Option<{}>", base_type)
        }
    }

    /// Check if a type specification needs validation.
    pub fn needs_validation(&self, type_spec: &crate::parser::TypeSpec) -> bool {
        use crate::parser::TypeSpec;

        match type_spec {
            TypeSpec::Int8 { range } => range.is_some(),
            TypeSpec::Int16 { range } => range.is_some(),
            TypeSpec::Int32 { range } => range.is_some(),
            TypeSpec::Int64 { range } => range.is_some(),
            TypeSpec::Uint8 { range } => range.is_some(),
            TypeSpec::Uint16 { range } => range.is_some(),
            TypeSpec::Uint32 { range } => range.is_some(),
            TypeSpec::Uint64 { range } => range.is_some(),
            TypeSpec::String { length, pattern } => length.is_some() || pattern.is_some(),
            TypeSpec::Binary { length } => length.is_some(),
            _ => false,
        }
    }

    /// Get the validated type name for a type specification.
    pub fn get_validated_type_name(&self, type_spec: &crate::parser::TypeSpec) -> String {
        use crate::parser::TypeSpec;

        match type_spec {
            TypeSpec::Int8 { range } if range.is_some() => {
                format!("ValidatedInt8Id{}", self.constraint_hash(type_spec))
            }
            TypeSpec::Int16 { range } if range.is_some() => {
                format!("ValidatedInt16Id{}", self.constraint_hash(type_spec))
            }
            TypeSpec::Int32 { range } if range.is_some() => {
                format!("ValidatedInt32Id{}", self.constraint_hash(type_spec))
            }
            TypeSpec::Int64 { range } if range.is_some() => {
                format!("ValidatedInt64Id{}", self.constraint_hash(type_spec))
            }
            TypeSpec::Uint8 { range } if range.is_some() => {
                format!("ValidatedUint8Id{}", self.constraint_hash(type_spec))
            }
            TypeSpec::Uint16 { range } if range.is_some() => {
                format!("ValidatedUint16Id{}", self.constraint_hash(type_spec))
            }
            TypeSpec::Uint32 { range } if range.is_some() => {
                format!("ValidatedUint32Id{}", self.constraint_hash(type_spec))
            }
            TypeSpec::Uint64 { range } if range.is_some() => {
                format!("ValidatedUint64Id{}", self.constraint_hash(type_spec))
            }
            TypeSpec::String { length, pattern } if length.is_some() || pattern.is_some() => {
                format!("ValidatedStringId{}", self.constraint_hash(type_spec))
            }
            TypeSpec::Binary { length } if length.is_some() => {
                format!("ValidatedBinaryId{}", self.constraint_hash(type_spec))
            }
            _ => "Unknown".to_string(),
        }
    }

    /// Generate a hash for constraint uniqueness.
    pub fn constraint_hash(&self, type_spec: &crate::parser::TypeSpec) -> String {
        use crate::parser::TypeSpec;
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher = DefaultHasher::new();

        match type_spec {
            TypeSpec::Int8 { range: Some(r) }
            | TypeSpec::Int16 { range: Some(r) }
            | TypeSpec::Int32 { range: Some(r) }
            | TypeSpec::Int64 { range: Some(r) }
            | TypeSpec::Uint8 { range: Some(r) }
            | TypeSpec::Uint16 { range: Some(r) }
            | TypeSpec::Uint32 { range: Some(r) }
            | TypeSpec::Uint64 { range: Some(r) } => {
                for range in &r.ranges {
                    range.min.hash(&mut hasher);
                    range.max.hash(&mut hasher);
                }
            }
            TypeSpec::String { length, pattern } => {
                if let Some(l) = length {
                    for len in &l.lengths {
                        len.min.hash(&mut hasher);
                        len.max.hash(&mut hasher);
                    }
                }
                if let Some(p) = pattern {
                    p.pattern.hash(&mut hasher);
                }
            }
            TypeSpec::Binary { length: Some(l) } => {
                for len in &l.lengths {
                    len.min.hash(&mut hasher);
                    len.max.hash(&mut hasher);
                }
            }
            _ => {}
        }

        format!("{:x}", hasher.finish())
    }

    /// Generate rustdoc comments from a YANG description.
    fn generate_rustdoc(&self, description: &str) -> String {
        let mut rustdoc = String::new();

        // Split description into lines and format as rustdoc comments
        for line in description.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() {
                rustdoc.push_str("///\n");
            } else {
                rustdoc.push_str(&format!("/// {}\n", trimmed));
            }
        }

        rustdoc
    }

    /// Get the JSON field name for a YANG node, with optional namespace prefix.
    ///
    /// For RESTCONF JSON compliance (RFC 8040), field names can be prefixed with
    /// the module prefix when namespace prefixes are enabled.
    fn get_json_field_name(&self, yang_name: &str, module: &YangModule) -> String {
        if self.config.enable_namespace_prefixes {
            format!("{}:{}", module.prefix, yang_name)
        } else {
            yang_name.to_string()
        }
    }

    /// Generate derive attributes based on configuration.
    fn generate_derive_attributes(&self) -> String {
        let mut derives = vec!["Serialize", "Deserialize"];

        if self.config.derive_debug {
            derives.insert(0, "Debug");
        }

        if self.config.derive_clone {
            derives.insert(if self.config.derive_debug { 1 } else { 0 }, "Clone");
        }

        format!("#[derive({})]\n", derives.join(", "))
    }
}
