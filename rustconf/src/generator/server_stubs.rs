//! Server stub handler implementation generation module.
//!
//! This module generates stub implementations of handler traits that return
//! sensible default values. Stub handlers can be used as-is for testing or
//! selectively overridden for production use.

use crate::generator::{GeneratorConfig, GeneratorError};
use crate::parser::{DataNode, Rpc, TypeSpec, YangModule};

/// Generator for server stub handler implementations.
#[allow(dead_code)]
pub struct StubHandlerGenerator<'a> {
    config: &'a GeneratorConfig,
}

#[allow(dead_code)]
impl<'a> StubHandlerGenerator<'a> {
    /// Create a new stub handler generator with the given configuration.
    pub fn new(config: &'a GeneratorConfig) -> Self {
        Self { config }
    }

    /// Generate the stub implementation for a YANG module's handler trait.
    ///
    /// This creates a struct that implements the handler trait with methods
    /// that return sensible default values and log all invocations.
    pub fn generate_stub_impl(&self, module: &YangModule) -> Result<String, GeneratorError> {
        let mut output = String::new();

        // Generate file header
        output.push_str("// This file is automatically generated by rustconf.\n");
        output.push_str("// DO NOT EDIT MANUALLY.\n\n");

        // Add use statements
        output.push_str("use async_trait::async_trait;\n");
        output.push_str("use rustconf_runtime::ServerError;\n");
        output.push_str("use std::sync::{Arc, Mutex};\n");
        output.push_str("use super::handlers::*;\n");
        output.push_str("use super::types::*;\n");
        output.push('\n');

        // Generate struct name from module name
        let trait_name = self.generate_trait_name(module);
        let struct_name = format!("Stub{}", trait_name);

        // Generate struct documentation
        output.push_str(&format!("/// Stub implementation of {}.\n", trait_name));
        output.push_str("///\n");
        output.push_str(
            "/// This implementation returns sensible default values for all operations.\n",
        );
        output
            .push_str("/// Use as-is for testing, or override specific methods for production.\n");
        output.push_str("///\n");
        output.push_str("/// All method invocations are logged for debugging purposes.\n");

        // Generate struct definition
        output.push_str("#[derive(Debug, Clone)]\n");
        output.push_str(&format!("pub struct {} {{\n", struct_name));
        output.push_str("    /// Log of handler method calls for debugging.\n");
        output.push_str("    call_log: Arc<Mutex<Vec<String>>>,\n");
        output.push_str("}\n\n");

        // Generate impl block with constructor and accessor
        output.push_str(&format!("impl {} {{\n", struct_name));
        output.push_str("    /// Create a new stub handler.\n");
        output.push_str("    pub fn new() -> Self {\n");
        output.push_str("        Self {\n");
        output.push_str("            call_log: Arc::new(Mutex::new(Vec::new())),\n");
        output.push_str("        }\n");
        output.push_str("    }\n\n");

        output.push_str("    /// Get the log of handler calls for debugging and testing.\n");
        output.push_str("    pub fn get_call_log(&self) -> Vec<String> {\n");
        output.push_str("        self.call_log.lock().unwrap().clone()\n");
        output.push_str("    }\n");
        output.push_str("}\n\n");

        // Generate Default impl
        output.push_str(&format!("impl Default for {} {{\n", struct_name));
        output.push_str("    fn default() -> Self {\n");
        output.push_str("        Self::new()\n");
        output.push_str("    }\n");
        output.push_str("}\n\n");

        // Generate trait implementation
        output.push_str("#[async_trait]\n");
        output.push_str(&format!("impl {} for {} {{\n", trait_name, struct_name));

        // Generate stub methods for RPC operations
        for rpc in &module.rpcs {
            output.push_str(&self.generate_rpc_stub_method(rpc, module)?);
            output.push('\n');
        }

        // Generate stub methods for data node CRUD operations
        for node in &module.data_nodes {
            output.push_str(&self.generate_data_node_stub_methods(node, module)?);
        }

        output.push_str("}\n");

        Ok(output)
    }

    /// Generate the trait name from the module name.
    fn generate_trait_name(&self, module: &YangModule) -> String {
        let module_type_name = crate::generator::naming::to_type_name(&module.name);
        format!("{}Handler", module_type_name)
    }

    /// Generate a stub method for an RPC operation.
    fn generate_rpc_stub_method(
        &self,
        rpc: &Rpc,
        _module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();

        let method_name = crate::generator::naming::to_field_name(&rpc.name);
        let rpc_type_name = crate::generator::naming::to_type_name(&rpc.name);

        // Generate method signature
        output.push_str("    async fn ");
        output.push_str(&method_name);
        output.push('(');
        output.push_str("&self");

        // Add input parameter if RPC has input
        let has_input = rpc.input.as_ref().is_some_and(|nodes| !nodes.is_empty());
        if has_input {
            output.push_str(", input: ");
            output.push_str(&format!("{}Input", rpc_type_name));
        }

        output.push_str(") -> Result<");

        // Determine return type based on output
        let has_output = rpc.output.as_ref().is_some_and(|nodes| !nodes.is_empty());
        let output_type = if has_output {
            format!("{}Output", rpc_type_name)
        } else {
            "()".to_string()
        };

        output.push_str(&output_type);
        output.push_str(", ServerError> {\n");

        // Generate method body
        // Log the call
        output.push_str("        self.call_log.lock().unwrap().push(\n");
        if has_input {
            output.push_str(&format!(
                "            format!(\"{}({{:?}})\", input)\n",
                method_name
            ));
        } else {
            output.push_str(&format!("            \"{}()\".to_string()\n", method_name));
        }
        output.push_str("        );\n\n");

        // Return default value
        if has_output {
            // Generate default value for output type
            if let Some(ref output_nodes) = rpc.output {
                output.push_str(&format!("        Ok({} {{\n", output_type));
                for node in output_nodes {
                    if let DataNode::Leaf(leaf) = node {
                        let field_name = crate::generator::naming::to_field_name(&leaf.name);
                        let default_value =
                            self.default_value_for_type(&leaf.type_spec, leaf.mandatory)?;
                        output
                            .push_str(&format!("            {}: {},\n", field_name, default_value));
                    }
                }
                output.push_str("        })\n");
            } else {
                output.push_str("        Ok(Default::default())\n");
            }
        } else {
            output.push_str("        Ok(())\n");
        }

        output.push_str("    }");

        Ok(output)
    }

    /// Generate stub methods for a data node.
    fn generate_data_node_stub_methods(
        &self,
        node: &DataNode,
        module: &YangModule,
    ) -> Result<String, GeneratorError> {
        match node {
            DataNode::Container(container) => {
                self.generate_container_stub_methods(container, module)
            }
            DataNode::List(list) => self.generate_list_stub_methods(list, module),
            _ => Ok(String::new()),
        }
    }

    /// Generate stub methods for a container.
    fn generate_container_stub_methods(
        &self,
        container: &crate::parser::Container,
        _module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();
        let type_name = crate::generator::naming::to_type_name(&container.name);
        let method_prefix = crate::generator::naming::to_field_name(&container.name);

        // GET method
        output.push_str(&format!(
            "    async fn get_{}(&self) -> Result<{}, ServerError> {{\n",
            method_prefix, type_name
        ));
        output.push_str("        self.call_log.lock().unwrap().push(\n");
        output.push_str(&format!(
            "            \"get_{}()\".to_string()\n",
            method_prefix
        ));
        output.push_str("        );\n\n");
        output.push_str(&format!("        Ok({} {{\n", type_name));

        // Generate default values for all fields
        for child in &container.children {
            if let DataNode::Leaf(leaf) = child {
                let field_name = crate::generator::naming::to_field_name(&leaf.name);
                let default_value = self.default_value_for_type(&leaf.type_spec, leaf.mandatory)?;
                output.push_str(&format!("            {}: {},\n", field_name, default_value));
            } else if let DataNode::Container(nested) = child {
                let field_name = crate::generator::naming::to_field_name(&nested.name);
                if nested.mandatory {
                    output.push_str(&format!(
                        "            {}: Default::default(),\n",
                        field_name
                    ));
                } else {
                    output.push_str(&format!("            {}: None,\n", field_name));
                }
            } else if let DataNode::List(_) = child {
                let field_name = crate::generator::naming::to_field_name(child.name());
                output.push_str(&format!("            {}: Vec::new(),\n", field_name));
            }
        }

        output.push_str("        })\n");
        output.push_str("    }\n\n");

        // Config-based methods
        if container.config {
            // PUT method
            output.push_str(&format!(
                "    async fn put_{}(&self, data: {}) -> Result<(), ServerError> {{\n",
                method_prefix, type_name
            ));
            output.push_str("        self.call_log.lock().unwrap().push(\n");
            output.push_str(&format!(
                "            format!(\"put_{}({{:?}})\", data)\n",
                method_prefix
            ));
            output.push_str("        );\n\n");
            output.push_str("        Ok(())\n");
            output.push_str("    }\n\n");

            // PATCH method
            output.push_str(&format!(
                "    async fn patch_{}(&self, data: {}) -> Result<(), ServerError> {{\n",
                method_prefix, type_name
            ));
            output.push_str("        self.call_log.lock().unwrap().push(\n");
            output.push_str(&format!(
                "            format!(\"patch_{}({{:?}})\", data)\n",
                method_prefix
            ));
            output.push_str("        );\n\n");
            output.push_str("        Ok(())\n");
            output.push_str("    }\n\n");

            // DELETE method
            output.push_str(&format!(
                "    async fn delete_{}(&self) -> Result<(), ServerError> {{\n",
                method_prefix
            ));
            output.push_str("        self.call_log.lock().unwrap().push(\n");
            output.push_str(&format!(
                "            \"delete_{}()\".to_string()\n",
                method_prefix
            ));
            output.push_str("        );\n\n");
            output.push_str("        Ok(())\n");
            output.push_str("    }\n\n");
        }

        Ok(output)
    }

    /// Generate stub methods for a list.
    fn generate_list_stub_methods(
        &self,
        list: &crate::parser::List,
        _module: &YangModule,
    ) -> Result<String, GeneratorError> {
        let mut output = String::new();
        let type_name = crate::generator::naming::to_type_name(&list.name);
        let method_prefix = crate::generator::naming::to_field_name(&list.name);

        // Determine item type name (singular)
        let item_type_name = if type_name.ends_with('s') && type_name.len() > 1 {
            type_name[..type_name.len() - 1].to_string()
        } else {
            type_name.clone()
        };

        // Generate key parameters
        let key_params = self.generate_list_key_params(list);
        let key_log_format = self.generate_key_log_format(list);

        // GET method for entire list
        output.push_str(&format!(
            "    async fn get_{}(&self) -> Result<Vec<{}>, ServerError> {{\n",
            method_prefix, item_type_name
        ));
        output.push_str("        self.call_log.lock().unwrap().push(\n");
        output.push_str(&format!(
            "            \"get_{}()\".to_string()\n",
            method_prefix
        ));
        output.push_str("        );\n\n");
        output.push_str("        Ok(Vec::new())\n");
        output.push_str("    }\n\n");

        // GET method for single item by key
        output.push_str(&format!(
            "    async fn get_{}_by_key(&self, {}) -> Result<{}, ServerError> {{\n",
            method_prefix, key_params, item_type_name
        ));
        output.push_str("        self.call_log.lock().unwrap().push(\n");
        output.push_str(&format!(
            "            format!(\"get_{}_by_key({})\", {})\n",
            method_prefix,
            key_log_format,
            self.generate_key_args(list)
        ));
        output.push_str("        );\n\n");

        // Generate default item
        output.push_str(&format!("        Ok({} {{\n", item_type_name));
        for child in &list.children {
            if let DataNode::Leaf(leaf) = child {
                let field_name = crate::generator::naming::to_field_name(&leaf.name);
                let is_key = list.keys.contains(&leaf.name);
                let default_value =
                    self.default_value_for_type(&leaf.type_spec, is_key || leaf.mandatory)?;
                output.push_str(&format!("            {}: {},\n", field_name, default_value));
            } else if let DataNode::Container(nested) = child {
                let field_name = crate::generator::naming::to_field_name(&nested.name);
                if nested.mandatory {
                    output.push_str(&format!(
                        "            {}: Default::default(),\n",
                        field_name
                    ));
                } else {
                    output.push_str(&format!("            {}: None,\n", field_name));
                }
            } else if let DataNode::List(_) = child {
                let field_name = crate::generator::naming::to_field_name(child.name());
                output.push_str(&format!("            {}: Vec::new(),\n", field_name));
            }
        }
        output.push_str("        })\n");
        output.push_str("    }\n\n");

        // Config-based methods
        if list.config {
            // POST method - create new item
            output.push_str(&format!(
                "    async fn create_{}(&self, data: {}) -> Result<(), ServerError> {{\n",
                method_prefix, item_type_name
            ));
            output.push_str("        self.call_log.lock().unwrap().push(\n");
            output.push_str(&format!(
                "            format!(\"create_{}({{:?}})\", data)\n",
                method_prefix
            ));
            output.push_str("        );\n\n");
            output.push_str("        Ok(())\n");
            output.push_str("    }\n\n");

            // PUT method - replace item by key
            output.push_str(&format!(
                "    async fn put_{}(&self, {}, data: {}) -> Result<(), ServerError> {{\n",
                method_prefix, key_params, item_type_name
            ));
            output.push_str("        self.call_log.lock().unwrap().push(\n");
            output.push_str(&format!(
                "            format!(\"put_{}({}, {{:?}})\", {}, data)\n",
                method_prefix,
                key_log_format,
                self.generate_key_args(list)
            ));
            output.push_str("        );\n\n");
            output.push_str("        Ok(())\n");
            output.push_str("    }\n\n");

            // PATCH method - partial update by key
            output.push_str(&format!(
                "    async fn patch_{}(&self, {}, data: {}) -> Result<(), ServerError> {{\n",
                method_prefix, key_params, item_type_name
            ));
            output.push_str("        self.call_log.lock().unwrap().push(\n");
            output.push_str(&format!(
                "            format!(\"patch_{}({}, {{:?}})\", {}, data)\n",
                method_prefix,
                key_log_format,
                self.generate_key_args(list)
            ));
            output.push_str("        );\n\n");
            output.push_str("        Ok(())\n");
            output.push_str("    }\n\n");

            // DELETE method - remove item by key
            output.push_str(&format!(
                "    async fn delete_{}(&self, {}) -> Result<(), ServerError> {{\n",
                method_prefix, key_params
            ));
            output.push_str("        self.call_log.lock().unwrap().push(\n");
            output.push_str(&format!(
                "            format!(\"delete_{}({})\", {})\n",
                method_prefix,
                key_log_format,
                self.generate_key_args(list)
            ));
            output.push_str("        );\n\n");
            output.push_str("        Ok(())\n");
            output.push_str("    }\n\n");
        }

        Ok(output)
    }

    /// Generate key parameters for list operations.
    fn generate_list_key_params(&self, list: &crate::parser::List) -> String {
        let mut params = Vec::new();

        for key_name in &list.keys {
            // Find the leaf node for this key to determine its type
            let key_type = self.find_key_type(key_name, &list.children);
            let param_name = crate::generator::naming::to_field_name(key_name);
            params.push(format!("{}: {}", param_name, key_type));
        }

        params.join(", ")
    }

    /// Generate format string for logging key parameters.
    fn generate_key_log_format(&self, list: &crate::parser::List) -> String {
        list.keys
            .iter()
            .map(|_| "{:?}")
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate arguments for logging key parameters.
    fn generate_key_args(&self, list: &crate::parser::List) -> String {
        list.keys
            .iter()
            .map(|key_name| crate::generator::naming::to_field_name(key_name))
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Find the type of a key field in the list children.
    fn find_key_type(&self, key_name: &str, children: &[DataNode]) -> String {
        for child in children {
            if let DataNode::Leaf(leaf) = child {
                if leaf.name == key_name {
                    // Generate the type for this leaf (always mandatory for keys)
                    let type_gen = crate::generator::types::TypeGenerator::new(self.config);
                    return type_gen.generate_leaf_type(&leaf.type_spec, true);
                }
            }
        }

        // Default to String if key type not found
        "String".to_string()
    }

    /// Generate a default value for a YANG type.
    ///
    /// Returns sensible defaults:
    /// - 0 for numeric types
    /// - "" for strings
    /// - false for booleans
    /// - None for optional types
    /// - Default::default() for complex types
    fn default_value_for_type(
        &self,
        type_spec: &TypeSpec,
        mandatory: bool,
    ) -> Result<String, GeneratorError> {
        if !mandatory {
            return Ok("None".to_string());
        }

        let default = match type_spec {
            TypeSpec::Int8 { .. } => "0i8",
            TypeSpec::Int16 { .. } => "0i16",
            TypeSpec::Int32 { .. } => "0i32",
            TypeSpec::Int64 { .. } => "0i64",
            TypeSpec::Uint8 { .. } => "0u8",
            TypeSpec::Uint16 { .. } => "0u16",
            TypeSpec::Uint32 { .. } => "0u32",
            TypeSpec::Uint64 { .. } => "0u64",
            TypeSpec::String { .. } => "String::new()",
            TypeSpec::Boolean => "false",
            TypeSpec::Empty => "()",
            TypeSpec::Binary { .. } => "Vec::new()",
            TypeSpec::Enumeration { .. } => "String::new()",
            TypeSpec::Union { .. } => "String::new()",
            TypeSpec::LeafRef { .. } => "String::new()",
            TypeSpec::TypedefRef { .. } => "Default::default()",
        };

        Ok(default.to_string())
    }
}

// Helper trait to get the name of a DataNode
trait DataNodeName {
    fn name(&self) -> &str;
}

impl DataNodeName for DataNode {
    fn name(&self) -> &str {
        match self {
            DataNode::Container(c) => &c.name,
            DataNode::List(l) => &l.name,
            DataNode::Leaf(l) => &l.name,
            DataNode::LeafList(l) => &l.name,
            DataNode::Choice(c) => &c.name,
            DataNode::Case(c) => &c.name,
            DataNode::Uses(u) => &u.name,
        }
    }
}
