//! Unit tests for code generator module.

use std::path::PathBuf;
use tempfile::TempDir;

use crate::parser::{YangModule, YangVersion};

use super::*;

#[test]
fn test_generate_creates_generated_code() {
    let config = GeneratorConfig {
        output_dir: PathBuf::from("test_output"),
        module_name: "test_module".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test-module".to_string(),
        namespace: "urn:test:module".to_string(),
        prefix: "test".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let result = generator.generate(&module);
    assert!(result.is_ok());

    let generated = result.unwrap();
    assert_eq!(generated.file_count(), 1);
    assert!(generated.total_size() > 0);
}

#[test]
fn test_generated_file_has_correct_path() {
    let config = GeneratorConfig {
        output_dir: PathBuf::from("output"),
        module_name: "my_module".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let file = &generated.files[0];

    assert_eq!(file.path, PathBuf::from("output/my_module.rs"));
}

#[test]
fn test_generated_content_has_header() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "example-module".to_string(),
        namespace: "urn:example:module".to_string(),
        prefix: "ex".to_string(),
        yang_version: Some(YangVersion::V1_0),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for header comments
    assert!(content.contains("This file is automatically generated by rustconf"));
    assert!(content.contains("DO NOT EDIT MANUALLY"));
    assert!(content.contains("Source YANG module: example-module"));
    assert!(content.contains("Namespace: urn:example:module"));
    assert!(content.contains("Prefix: ex"));
    assert!(content.contains("YANG version: 1.0"));
    assert!(content.contains("Generated at:"));
}

#[test]
fn test_generated_content_has_use_statements() {
    let config = GeneratorConfig {
        enable_xml: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for serde use statement
    assert!(content.contains("use serde::{Deserialize, Serialize}"));
}

#[test]
fn test_generated_content_has_xml_use_when_enabled() {
    let config = GeneratorConfig {
        enable_xml: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for XML use statement with feature gate
    assert!(content.contains("#[cfg(feature = \"xml\")]"));
    assert!(content.contains("use serde_xml_rs"));
}

#[test]
fn test_generated_content_has_module_documentation() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "interface-config".to_string(),
        namespace: "urn:ietf:params:xml:ns:yang:interface".to_string(),
        prefix: "if".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for module documentation
    assert!(content.contains("//! Generated Rust bindings for YANG module: interface-config"));
    assert!(content.contains("//! Namespace: urn:ietf:params:xml:ns:yang:interface"));
}

#[test]
fn test_write_files_creates_output_directory() {
    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let result = generator.write_files(&generated);

    assert!(result.is_ok());
    assert!(output_dir.exists());
    assert!(output_dir.join("test.rs").exists());
}

#[test]
fn test_write_files_writes_correct_content() {
    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("output");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "example".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "example".to_string(),
        namespace: "urn:example".to_string(),
        prefix: "ex".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let file_path = output_dir.join("example.rs");
    let written_content = std::fs::read_to_string(file_path).unwrap();

    assert_eq!(written_content, generated.files[0].content);
}

#[test]
fn test_generated_code_file_count() {
    let generated = GeneratedCode {
        files: vec![
            GeneratedFile {
                path: PathBuf::from("file1.rs"),
                content: "content1".to_string(),
            },
            GeneratedFile {
                path: PathBuf::from("file2.rs"),
                content: "content2".to_string(),
            },
        ],
    };

    assert_eq!(generated.file_count(), 2);
}

#[test]
fn test_generated_code_total_size() {
    let generated = GeneratedCode {
        files: vec![
            GeneratedFile {
                path: PathBuf::from("file1.rs"),
                content: "hello".to_string(), // 5 bytes
            },
            GeneratedFile {
                path: PathBuf::from("file2.rs"),
                content: "world!".to_string(), // 6 bytes
            },
        ],
    };

    assert_eq!(generated.total_size(), 11);
}

#[test]
fn test_header_includes_yang_version_when_present() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module_v1_0 = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: Some(YangVersion::V1_0),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module_v1_0).unwrap();
    assert!(generated.files[0].content.contains("YANG version: 1.0"));

    let module_v1_1 = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module_v1_1).unwrap();
    assert!(generated.files[0].content.contains("YANG version: 1.1"));
}

#[test]
fn test_header_omits_yang_version_when_absent() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    assert!(!generated.files[0].content.contains("YANG version:"));
}

#[test]
fn test_generate_simple_container() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface-config".to_string(),
            description: Some("Interface configuration data".to_string()),
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: Some("Interface name".to_string()),
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "enabled".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check struct definition
    assert!(content.contains("pub struct InterfaceConfig {"));

    // Check rustdoc comment
    assert!(content.contains("/// Interface configuration data"));

    // Check derive attributes
    assert!(content.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    // Check fields
    assert!(content.contains("pub name: String,"));
    assert!(content.contains("pub enabled: bool,"));

    // Check serde rename attributes
    assert!(content.contains("#[serde(rename = \"name\")]"));
    assert!(content.contains("#[serde(rename = \"enabled\")]"));
}

#[test]
fn test_generate_container_with_optional_fields() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "mtu".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint16 { range: None },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "description".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check optional field types
    assert!(content.contains("pub mtu: Option<u16>,"));
    assert!(content.contains("pub description: Option<String>,"));

    // Check skip_serializing_if attributes (now combined with rename)
    assert!(content.contains("skip_serializing_if = \"Option::is_none\""));
}

#[test]
fn test_generate_nested_containers() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface".to_string(),
            description: Some("Network interface".to_string()),
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Container(Container {
                    name: "config".to_string(),
                    description: Some("Configuration data".to_string()),
                    config: true,
                    mandatory: true,
                    children: vec![DataNode::Leaf(Leaf {
                        name: "enabled".to_string(),
                        description: None,
                        type_spec: TypeSpec::Boolean,
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check parent struct
    assert!(content.contains("pub struct Interface {"));
    assert!(content.contains("/// Network interface"));

    // Check nested container field
    assert!(content.contains("pub config: Config,"));
    assert!(content.contains("#[serde(rename = \"config\")]"));

    // Check nested struct definition
    assert!(content.contains("pub struct Config {"));
    assert!(content.contains("/// Configuration data"));
    assert!(content.contains("pub enabled: bool,"));
}

#[test]
fn test_generate_container_with_optional_nested_container() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Container(Container {
                name: "state".to_string(),
                description: Some("Operational state data".to_string()),
                config: false,
                mandatory: false,
                children: vec![DataNode::Leaf(Leaf {
                    name: "oper-status".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: false,
                })],
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check optional nested container
    assert!(content.contains("pub state: Option<State>,"));

    // Check nested struct
    assert!(content.contains("pub struct State {"));
    assert!(content.contains("/// Operational state data"));

    // Check field name conversion (kebab-case to snake_case)
    assert!(content.contains("pub oper_status: String,"));
    assert!(content.contains("#[serde(rename = \"oper-status\")]"));
}

#[test]
fn test_generate_empty_container() {
    use crate::parser::{Container, DataNode};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "empty-container".to_string(),
            description: Some("An empty container".to_string()),
            config: true,
            mandatory: false,
            children: vec![],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check struct definition
    assert!(content.contains("pub struct EmptyContainer {"));
    assert!(content.contains("/// An empty container"));

    // Check that struct is properly closed
    assert!(content.contains("}\n"));
}

#[test]
fn test_rustdoc_multiline_description() {
    use crate::parser::{Container, DataNode};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: Some("This is a multi-line description.\n\nIt has multiple paragraphs.\nAnd multiple lines.".to_string()),
            config: true,
            mandatory: false,
            children: vec![],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check multiline rustdoc
    assert!(content.contains("/// This is a multi-line description."));
    assert!(content.contains("///\n"));
    assert!(content.contains("/// It has multiple paragraphs."));
    assert!(content.contains("/// And multiple lines."));
}

#[test]
fn test_derive_attributes_configuration() {
    use crate::parser::{Container, DataNode};

    // Test with all derives enabled
    let config = GeneratorConfig {
        derive_debug: true,
        derive_clone: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "test".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    assert!(content.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    // Test with Debug disabled
    let config = GeneratorConfig {
        derive_debug: false,
        derive_clone: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);
    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    assert!(content.contains("#[derive(Clone, Serialize, Deserialize)]"));
    assert!(!content.contains("Debug"));

    // Test with Clone disabled
    let config = GeneratorConfig {
        derive_debug: true,
        derive_clone: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);
    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    assert!(content.contains("#[derive(Debug, Serialize, Deserialize)]"));
    assert!(!content.contains("Clone"));
}

#[test]
fn test_generate_simple_list() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "interfaces".to_string(),
            description: Some("List of network interfaces".to_string()),
            config: true,
            keys: vec!["name".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: Some("Interface name".to_string()),
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "enabled".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check struct definition for list item
    assert!(content.contains("pub struct Interface {"));

    // Check rustdoc comment
    assert!(content.contains("/// List of network interfaces"));

    // Check derive attributes
    assert!(content.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    // Check key field is non-optional
    assert!(content.contains("pub name: String,"));
    assert!(!content.contains("pub name: Option<String>"));

    // Check other fields
    assert!(content.contains("pub enabled: bool,"));

    // Check Vec type alias
    assert!(content.contains("pub type Interfaces = Vec<Interface>;"));
    assert!(content.contains("/// Collection of Interface items."));
}

#[test]
fn test_generate_list_with_multiple_keys() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "routes".to_string(),
            description: None,
            config: true,
            keys: vec!["destination".to_string(), "prefix-length".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "destination".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "prefix-length".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint8 { range: None },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "next-hop".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check struct definition
    assert!(content.contains("pub struct Route {"));

    // Check all key fields are non-optional
    assert!(content.contains("pub destination: String,"));
    assert!(content.contains("pub prefix_length: u8,"));
    assert!(!content.contains("pub destination: Option<String>"));
    assert!(!content.contains("pub prefix_length: Option<u8>"));

    // Check non-key optional field
    assert!(content.contains("pub next_hop: Option<String>,"));

    // Check Vec type alias
    assert!(content.contains("pub type Routes = Vec<Route>;"));
}

#[test]
fn test_generate_list_with_optional_fields() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "users".to_string(),
            description: None,
            config: true,
            keys: vec!["username".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "username".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "email".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "age".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint8 { range: None },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check key field is non-optional
    assert!(content.contains("pub username: String,"));

    // Check optional fields
    assert!(content.contains("pub email: Option<String>,"));
    assert!(content.contains("pub age: Option<u8>,"));

    // Check skip_serializing_if for optional fields
    assert!(content.contains("skip_serializing_if = \"Option::is_none\""));
}

#[test]
fn test_generate_list_as_container_field() {
    use crate::parser::{Container, DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "system".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::List(List {
                name: "users".to_string(),
                description: Some("System users".to_string()),
                config: true,
                keys: vec!["name".to_string()],
                children: vec![DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                })],
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check container struct
    assert!(content.contains("pub struct System {"));

    // Check list field in container
    assert!(content.contains("pub users: Users,"));
    assert!(content.contains("#[serde(rename = \"users\")]"));

    // Check list item struct
    assert!(content.contains("pub struct User {"));
    assert!(content.contains("/// System users"));

    // Check Vec type alias
    assert!(content.contains("pub type Users = Vec<User>;"));
}

#[test]
fn test_generate_nested_list() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "interfaces".to_string(),
            description: None,
            config: true,
            keys: vec!["name".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::List(List {
                    name: "addresses".to_string(),
                    description: Some("IP addresses".to_string()),
                    config: true,
                    keys: vec!["ip".to_string()],
                    children: vec![DataNode::Leaf(Leaf {
                        name: "ip".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check parent list
    assert!(content.contains("pub struct Interface {"));
    assert!(content.contains("pub type Interfaces = Vec<Interface>;"));

    // Check nested list field
    assert!(content.contains("pub addresses: Addresses,"));

    // Check nested list struct
    assert!(content.contains("pub struct Addresse {"));
    assert!(content.contains("/// IP addresses"));
    assert!(content.contains("pub type Addresses = Vec<Addresse>;"));
}

#[test]
fn test_list_key_field_always_non_optional() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    // Create a list where the key field is marked as non-mandatory in YANG
    // (which shouldn't happen, but we want to ensure keys are always non-optional)
    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "items".to_string(),
            description: None,
            config: true,
            keys: vec!["id".to_string()],
            children: vec![DataNode::Leaf(Leaf {
                name: "id".to_string(),
                description: None,
                type_spec: TypeSpec::Uint32 { range: None },
                mandatory: false, // Even if marked as non-mandatory
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Key field should still be non-optional
    assert!(content.contains("pub id: u32,"));
    assert!(!content.contains("pub id: Option<u32>"));
}

#[test]
fn test_generate_simple_choice() {
    use crate::parser::{Case, Choice, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "address-type".to_string(),
            description: Some("Address type selection".to_string()),
            mandatory: false,
            cases: vec![
                Case {
                    name: "ipv4".to_string(),
                    description: Some("IPv4 address".to_string()),
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "ipv4-address".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
                Case {
                    name: "ipv6".to_string(),
                    description: Some("IPv6 address".to_string()),
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "ipv6-address".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum AddressType {"));

    // Check rustdoc comment
    assert!(content.contains("/// Address type selection"));

    // Check derive attributes
    assert!(content.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    // Check serde rename_all attribute
    assert!(content.contains("#[serde(rename_all = \"kebab-case\")]"));

    // Check variants with tuple types (single leaf cases)
    assert!(content.contains("Ipv4(String)"));
    assert!(content.contains("Ipv6(String)"));

    // Check case rustdoc comments
    assert!(content.contains("/// IPv4 address"));
    assert!(content.contains("/// IPv6 address"));
}

#[test]
fn test_generate_choice_with_multiple_fields_per_case() {
    use crate::parser::{Case, Choice, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "transport".to_string(),
            description: Some("Transport protocol".to_string()),
            mandatory: true,
            cases: vec![
                Case {
                    name: "tcp".to_string(),
                    description: Some("TCP transport".to_string()),
                    data_nodes: vec![
                        DataNode::Leaf(Leaf {
                            name: "tcp-port".to_string(),
                            description: None,
                            type_spec: TypeSpec::Uint16 { range: None },
                            mandatory: true,
                            default: None,
                            config: true,
                        }),
                        DataNode::Leaf(Leaf {
                            name: "tcp-timeout".to_string(),
                            description: None,
                            type_spec: TypeSpec::Uint32 { range: None },
                            mandatory: false,
                            default: None,
                            config: true,
                        }),
                    ],
                },
                Case {
                    name: "udp".to_string(),
                    description: Some("UDP transport".to_string()),
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "udp-port".to_string(),
                        description: None,
                        type_spec: TypeSpec::Uint16 { range: None },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum Transport {"));

    // Check variants with struct types (multiple fields)
    assert!(content.contains("Tcp(TcpData)"));
    assert!(content.contains("Udp(u16)"));

    // Check case struct definition for TCP
    assert!(content.contains("pub struct TcpData {"));
    assert!(content.contains("pub tcp_port: u16,"));
    assert!(content.contains("pub tcp_timeout: Option<u32>,"));

    // Check serde attributes
    assert!(content.contains("#[serde(rename_all = \"kebab-case\")]"));
}

#[test]
fn test_generate_choice_with_empty_case() {
    use crate::parser::{Case, Choice, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "mode".to_string(),
            description: None,
            mandatory: false,
            cases: vec![
                Case {
                    name: "automatic".to_string(),
                    description: Some("Automatic mode".to_string()),
                    data_nodes: vec![],
                },
                Case {
                    name: "manual".to_string(),
                    description: Some("Manual mode".to_string()),
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "value".to_string(),
                        description: None,
                        type_spec: TypeSpec::Uint32 { range: None },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum Mode {"));

    // Check unit variant for empty case
    assert!(content.contains("Automatic,"));

    // Check tuple variant for single-field case
    assert!(content.contains("Manual(u32)"));
}

#[test]
fn test_generate_choice_with_nested_container() {
    use crate::parser::{Case, Choice, Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "config-type".to_string(),
            description: Some("Configuration type".to_string()),
            mandatory: false,
            cases: vec![Case {
                name: "advanced".to_string(),
                description: Some("Advanced configuration".to_string()),
                data_nodes: vec![DataNode::Container(Container {
                    name: "advanced-config".to_string(),
                    description: Some("Advanced settings".to_string()),
                    config: true,
                    mandatory: true,
                    children: vec![DataNode::Leaf(Leaf {
                        name: "setting".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                })],
            }],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum ConfigType {"));

    // Check variant with struct type (complex nested type)
    assert!(content.contains("Advanced(AdvancedData)"));

    // Check case struct definition
    assert!(content.contains("pub struct AdvancedData {"));
    assert!(content.contains("pub advanced_config: AdvancedConfig,"));

    // Check nested container struct
    assert!(content.contains("pub struct AdvancedConfig {"));
    assert!(content.contains("/// Advanced settings"));
    assert!(content.contains("pub setting: String,"));
}

#[test]
fn test_generate_choice_as_container_field() {
    use crate::parser::{Case, Choice, Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Choice(Choice {
                    name: "address-family".to_string(),
                    description: Some("Address family selection".to_string()),
                    mandatory: false,
                    cases: vec![
                        Case {
                            name: "ipv4".to_string(),
                            description: None,
                            data_nodes: vec![DataNode::Leaf(Leaf {
                                name: "ipv4-addr".to_string(),
                                description: None,
                                type_spec: TypeSpec::String {
                                    length: None,
                                    pattern: None,
                                },
                                mandatory: true,
                                default: None,
                                config: true,
                            })],
                        },
                        Case {
                            name: "ipv6".to_string(),
                            description: None,
                            data_nodes: vec![DataNode::Leaf(Leaf {
                                name: "ipv6-addr".to_string(),
                                description: None,
                                type_spec: TypeSpec::String {
                                    length: None,
                                    pattern: None,
                                },
                                mandatory: true,
                                default: None,
                                config: true,
                            })],
                        },
                    ],
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check container struct
    assert!(content.contains("pub struct Interface {"));

    // Check choice field in container (optional)
    assert!(content.contains("pub address_family: Option<AddressFamily>,"));
    assert!(content.contains("#[serde(rename = \"address-family\""));
    assert!(content.contains("skip_serializing_if = \"Option::is_none\""));

    // Check choice enum definition
    assert!(content.contains("pub enum AddressFamily {"));
    assert!(content.contains("#[serde(rename_all = \"kebab-case\")]"));
    assert!(content.contains("Ipv4(String)"));
    assert!(content.contains("Ipv6(String)"));
}

#[test]
fn test_generate_mandatory_choice_as_container_field() {
    use crate::parser::{Case, Choice, Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Choice(Choice {
                name: "protocol".to_string(),
                description: Some("Protocol selection".to_string()),
                mandatory: true,
                cases: vec![
                    Case {
                        name: "http".to_string(),
                        description: None,
                        data_nodes: vec![DataNode::Leaf(Leaf {
                            name: "http-port".to_string(),
                            description: None,
                            type_spec: TypeSpec::Uint16 { range: None },
                            mandatory: true,
                            default: None,
                            config: true,
                        })],
                    },
                    Case {
                        name: "https".to_string(),
                        description: None,
                        data_nodes: vec![DataNode::Leaf(Leaf {
                            name: "https-port".to_string(),
                            description: None,
                            type_spec: TypeSpec::Uint16 { range: None },
                            mandatory: true,
                            default: None,
                            config: true,
                        })],
                    },
                ],
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check container struct
    assert!(content.contains("pub struct Config {"));

    // Check mandatory choice field (non-optional)
    assert!(content.contains("pub protocol: Protocol,"));
    assert!(!content.contains("pub protocol: Option<Protocol>"));

    // Check choice enum definition
    assert!(content.contains("pub enum Protocol {"));
}

#[test]
fn test_generate_choice_with_nested_list() {
    use crate::parser::{Case, Choice, DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "data-source".to_string(),
            description: Some("Data source selection".to_string()),
            mandatory: false,
            cases: vec![Case {
                name: "database".to_string(),
                description: Some("Database source".to_string()),
                data_nodes: vec![DataNode::List(List {
                    name: "servers".to_string(),
                    description: Some("Database servers".to_string()),
                    config: true,
                    keys: vec!["host".to_string()],
                    children: vec![DataNode::Leaf(Leaf {
                        name: "host".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                })],
            }],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum DataSource {"));

    // Check variant with struct type (complex nested type)
    assert!(content.contains("Database(DatabaseData)"));

    // Check case struct definition
    assert!(content.contains("pub struct DatabaseData {"));
    assert!(content.contains("pub servers: Servers,"));

    // Check nested list struct
    assert!(content.contains("pub struct Server {"));
    assert!(content.contains("/// Database servers"));
    assert!(content.contains("pub type Servers = Vec<Server>;"));
}

#[test]
fn test_generate_validated_int_with_range() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "port".to_string(),
                description: Some("Port number".to_string()),
                type_spec: TypeSpec::Uint16 {
                    range: Some(RangeConstraint::new(vec![Range::new(1, 65535)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check ValidationError is generated
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("OutOfRange"));

    // Check validated type is generated
    assert!(content.contains("pub struct ValidatedUint16_"));
    assert!(content.contains("value: u16"));
    assert!(content.contains("pub fn new(value: u16) -> Result<Self, ValidationError>"));
    assert!(content.contains("pub fn value(&self) -> u16"));

    // Check TryFrom implementation
    assert!(content.contains("impl TryFrom<u16> for ValidatedUint16_"));

    // Check Serialize/Deserialize implementations
    assert!(content.contains("impl serde::Serialize for ValidatedUint16_"));
    assert!(content.contains("impl<'de> serde::Deserialize<'de> for ValidatedUint16_"));

    // Check field uses validated type
    assert!(content.contains("pub port: ValidatedUint16_"));
}

#[test]
fn test_generate_validated_string_with_length() {
    use crate::parser::{Container, DataNode, Leaf, LengthConstraint, LengthRange, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "user".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "username".to_string(),
                description: Some("Username".to_string()),
                type_spec: TypeSpec::String {
                    length: Some(LengthConstraint::new(vec![LengthRange::new(3, 20)])),
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check ValidationError is generated
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("InvalidLength"));

    // Check validated type is generated
    assert!(content.contains("pub struct ValidatedString_"));
    assert!(content.contains("value: String"));
    assert!(content.contains("pub fn new(value: String) -> Result<Self, ValidationError>"));
    assert!(content.contains("pub fn value(&self) -> &str"));

    // Check length validation logic
    assert!(content.contains("let length = value.len() as u64"));
    assert!(content.contains("length >= 3 && length <= 20"));

    // Check field uses validated type
    assert!(content.contains("pub username: ValidatedString_"));
}

#[test]
fn test_generate_validated_string_with_pattern() {
    use crate::parser::{Container, DataNode, Leaf, PatternConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "email".to_string(),
                description: Some("Email address".to_string()),
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: Some(PatternConstraint::new("[a-z]+@[a-z]+\\.[a-z]+".to_string())),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check ValidationError is generated
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("InvalidPattern"));

    // Check validated type is generated
    assert!(content.contains("pub struct ValidatedString_"));

    // Check pattern validation logic
    assert!(content.contains("regex::Regex::new"));
    assert!(content.contains("pattern.is_match"));

    // Check field uses validated type
    assert!(content.contains("pub email: ValidatedString_"));
}

#[test]
fn test_generate_optional_validated_type() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "timeout".to_string(),
                description: Some("Timeout in seconds".to_string()),
                type_spec: TypeSpec::Uint32 {
                    range: Some(RangeConstraint::new(vec![Range::new(1, 3600)])),
                },
                mandatory: false,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check validated type is generated
    assert!(content.contains("pub struct ValidatedUint32_"));

    // Check field uses Option<ValidatedType>
    assert!(content.contains("pub timeout: Option<ValidatedUint32_"));
}

#[test]
fn test_validation_disabled_uses_base_types() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "port".to_string(),
                description: Some("Port number".to_string()),
                type_spec: TypeSpec::Uint16 {
                    range: Some(RangeConstraint::new(vec![Range::new(1, 65535)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check ValidationError is NOT generated
    assert!(!content.contains("pub enum ValidationError"));

    // Check validated type is NOT generated
    assert!(!content.contains("pub struct ValidatedUint16_"));

    // Check field uses base type
    assert!(content.contains("pub port: u16,"));
}

#[test]
fn test_generate_multiple_validated_types() {
    use crate::parser::{
        Container, DataNode, Leaf, LengthConstraint, LengthRange, Range, RangeConstraint, TypeSpec,
    };

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "server".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "port".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint16 {
                        range: Some(RangeConstraint::new(vec![Range::new(1, 65535)])),
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "hostname".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: Some(LengthConstraint::new(vec![LengthRange::new(1, 255)])),
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check both validated types are generated
    assert!(content.contains("pub struct ValidatedUint16_"));
    assert!(content.contains("pub struct ValidatedString_"));

    // Check both fields use validated types
    assert!(content.contains("pub port: ValidatedUint16_"));
    assert!(content.contains("pub hostname: ValidatedString_"));
}

#[test]
fn test_validation_error_display_implementation() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "value".to_string(),
                description: None,
                type_spec: TypeSpec::Int32 {
                    range: Some(RangeConstraint::new(vec![Range::new(0, 100)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check Display implementation
    assert!(content.contains("impl std::fmt::Display for ValidationError"));
    assert!(content.contains("fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result"));

    // Check Error trait implementation
    assert!(content.contains("impl std::error::Error for ValidationError"));
}
