//! Unit tests for code generator module.

use std::path::PathBuf;
use tempfile::TempDir;

use crate::parser::{YangModule, YangVersion};

use super::*;

#[test]
fn test_generate_creates_generated_code() {
    let config = GeneratorConfig {
        output_dir: PathBuf::from("test_output"),
        module_name: "test_module".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test-module".to_string(),
        namespace: "urn:test:module".to_string(),
        prefix: "test".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let result = generator.generate(&module);
    assert!(result.is_ok());

    let generated = result.unwrap();
    assert_eq!(generated.file_count(), 1);
    assert!(generated.total_size() > 0);
}

#[test]
fn test_generated_file_has_correct_path() {
    let config = GeneratorConfig {
        output_dir: PathBuf::from("output"),
        module_name: "my_module".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let file = &generated.files[0];

    assert_eq!(file.path, PathBuf::from("output/my_module.rs"));
}

#[test]
fn test_generated_content_has_header() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "example-module".to_string(),
        namespace: "urn:example:module".to_string(),
        prefix: "ex".to_string(),
        yang_version: Some(YangVersion::V1_0),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for header comments
    assert!(content.contains("This file is automatically generated by rustconf"));
    assert!(content.contains("DO NOT EDIT MANUALLY"));
    assert!(content.contains("Source YANG module: example-module"));
    assert!(content.contains("Namespace: urn:example:module"));
    assert!(content.contains("Prefix: ex"));
    assert!(content.contains("YANG version: 1.0"));
    assert!(content.contains("Generated at:"));
}

#[test]
fn test_generated_content_has_use_statements() {
    let config = GeneratorConfig {
        enable_xml: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for serde use statement
    assert!(content.contains("use serde::{Deserialize, Serialize}"));
}

#[test]
fn test_generated_content_has_xml_use_when_enabled() {
    let config = GeneratorConfig {
        enable_xml: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for XML use statement with feature gate
    assert!(content.contains("#[cfg(feature = \"xml\")]"));
    assert!(content.contains("use serde_xml_rs"));
}

#[test]
fn test_generated_content_has_module_documentation() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "interface-config".to_string(),
        namespace: "urn:ietf:params:xml:ns:yang:interface".to_string(),
        prefix: "if".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for module documentation
    assert!(content.contains("// Generated Rust bindings for YANG module: interface-config"));
    assert!(content.contains("// Namespace: urn:ietf:params:xml:ns:yang:interface"));
}

#[test]
fn test_write_files_creates_output_directory() {
    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let result = generator.write_files(&generated);

    assert!(result.is_ok());
    assert!(output_dir.exists());
    assert!(output_dir.join("test.rs").exists());
}

#[test]
fn test_write_files_writes_correct_content() {
    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("output");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "example".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "example".to_string(),
        namespace: "urn:example".to_string(),
        prefix: "ex".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let file_path = output_dir.join("example.rs");
    let written_content = std::fs::read_to_string(file_path).unwrap();

    assert_eq!(written_content, generated.files[0].content);
}

#[test]
fn test_generated_code_file_count() {
    let generated = GeneratedCode {
        files: vec![
            GeneratedFile {
                path: PathBuf::from("file1.rs"),
                content: "content1".to_string(),
            },
            GeneratedFile {
                path: PathBuf::from("file2.rs"),
                content: "content2".to_string(),
            },
        ],
    };

    assert_eq!(generated.file_count(), 2);
}

#[test]
fn test_generated_code_total_size() {
    let generated = GeneratedCode {
        files: vec![
            GeneratedFile {
                path: PathBuf::from("file1.rs"),
                content: "hello".to_string(), // 5 bytes
            },
            GeneratedFile {
                path: PathBuf::from("file2.rs"),
                content: "world!".to_string(), // 6 bytes
            },
        ],
    };

    assert_eq!(generated.total_size(), 11);
}

#[test]
fn test_header_includes_yang_version_when_present() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module_v1_0 = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: Some(YangVersion::V1_0),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module_v1_0).unwrap();
    assert!(generated.files[0].content.contains("YANG version: 1.0"));

    let module_v1_1 = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module_v1_1).unwrap();
    assert!(generated.files[0].content.contains("YANG version: 1.1"));
}

#[test]
fn test_header_omits_yang_version_when_absent() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    assert!(!generated.files[0].content.contains("YANG version:"));
}

#[test]
fn test_generate_simple_container() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface-config".to_string(),
            description: Some("Interface configuration data".to_string()),
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: Some("Interface name".to_string()),
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "enabled".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check struct definition
    assert!(content.contains("pub struct InterfaceConfig {"));

    // Check rustdoc comment
    assert!(content.contains("/// Interface configuration data"));

    // Check derive attributes
    assert!(content.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    // Check fields
    assert!(content.contains("pub name: String,"));
    assert!(content.contains("pub enabled: bool,"));

    // Check serde rename attributes
    assert!(content.contains("#[serde(rename = \"name\")]"));
    assert!(content.contains("#[serde(rename = \"enabled\")]"));
}

#[test]
fn test_generate_container_with_optional_fields() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "mtu".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint16 { range: None },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "description".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check optional field types
    assert!(content.contains("pub mtu: Option<u16>,"));
    assert!(content.contains("pub description: Option<String>,"));

    // Check skip_serializing_if attributes (now combined with rename)
    assert!(content.contains("skip_serializing_if = \"Option::is_none\""));
}

#[test]
fn test_generate_nested_containers() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface".to_string(),
            description: Some("Network interface".to_string()),
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Container(Container {
                    name: "config".to_string(),
                    description: Some("Configuration data".to_string()),
                    config: true,
                    mandatory: true,
                    children: vec![DataNode::Leaf(Leaf {
                        name: "enabled".to_string(),
                        description: None,
                        type_spec: TypeSpec::Boolean,
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check parent struct
    assert!(content.contains("pub struct Interface {"));
    assert!(content.contains("/// Network interface"));

    // Check nested container field
    assert!(content.contains("pub config: Config,"));
    assert!(content.contains("#[serde(rename = \"config\")]"));

    // Check nested struct definition
    assert!(content.contains("pub struct Config {"));
    assert!(content.contains("/// Configuration data"));
    assert!(content.contains("pub enabled: bool,"));
}

#[test]
fn test_generate_container_with_optional_nested_container() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Container(Container {
                name: "state".to_string(),
                description: Some("Operational state data".to_string()),
                config: false,
                mandatory: false,
                children: vec![DataNode::Leaf(Leaf {
                    name: "oper-status".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: false,
                })],
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check optional nested container
    assert!(content.contains("pub state: Option<State>,"));

    // Check nested struct
    assert!(content.contains("pub struct State {"));
    assert!(content.contains("/// Operational state data"));

    // Check field name conversion (kebab-case to snake_case)
    assert!(content.contains("pub oper_status: String,"));
    assert!(content.contains("#[serde(rename = \"oper-status\")]"));
}

#[test]
fn test_generate_empty_container() {
    use crate::parser::{Container, DataNode};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "empty-container".to_string(),
            description: Some("An empty container".to_string()),
            config: true,
            mandatory: false,
            children: vec![],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check struct definition
    assert!(content.contains("pub struct EmptyContainer {"));
    assert!(content.contains("/// An empty container"));

    // Check that struct is properly closed
    assert!(content.contains("}\n"));
}

#[test]
fn test_rustdoc_multiline_description() {
    use crate::parser::{Container, DataNode};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: Some("This is a multi-line description.\n\nIt has multiple paragraphs.\nAnd multiple lines.".to_string()),
            config: true,
            mandatory: false,
            children: vec![],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check multiline rustdoc
    assert!(content.contains("/// This is a multi-line description."));
    assert!(content.contains("///\n"));
    assert!(content.contains("/// It has multiple paragraphs."));
    assert!(content.contains("/// And multiple lines."));
}

#[test]
fn test_derive_attributes_configuration() {
    use crate::parser::{Container, DataNode};

    // Test with all derives enabled
    let config = GeneratorConfig {
        derive_debug: true,
        derive_clone: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "test".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    assert!(content.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    // Test with Debug disabled
    let config = GeneratorConfig {
        derive_debug: false,
        derive_clone: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);
    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    assert!(content.contains("#[derive(Clone, Serialize, Deserialize)]"));
    assert!(!content.contains("Debug"));

    // Test with Clone disabled
    let config = GeneratorConfig {
        derive_debug: true,
        derive_clone: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);
    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    assert!(content.contains("#[derive(Debug, Serialize, Deserialize)]"));
    assert!(!content.contains("Clone"));
}

#[test]
fn test_generate_simple_list() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "interfaces".to_string(),
            description: Some("List of network interfaces".to_string()),
            config: true,
            keys: vec!["name".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: Some("Interface name".to_string()),
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "enabled".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check struct definition for list item
    assert!(content.contains("pub struct Interface {"));

    // Check rustdoc comment
    assert!(content.contains("/// List of network interfaces"));

    // Check derive attributes
    assert!(content.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    // Check key field is non-optional
    assert!(content.contains("pub name: String,"));
    assert!(!content.contains("pub name: Option<String>"));

    // Check other fields
    assert!(content.contains("pub enabled: bool,"));
}

#[test]
fn test_generate_list_with_multiple_keys() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "routes".to_string(),
            description: None,
            config: true,
            keys: vec!["destination".to_string(), "prefix-length".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "destination".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "prefix-length".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint8 { range: None },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "next-hop".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check struct definition
    assert!(content.contains("pub struct Route {"));

    // Check all key fields are non-optional
    assert!(content.contains("pub destination: String,"));
    assert!(content.contains("pub prefix_length: u8,"));
    assert!(!content.contains("pub destination: Option<String>"));
    assert!(!content.contains("pub prefix_length: Option<u8>"));

    // Check non-key optional field
    assert!(content.contains("pub next_hop: Option<String>,"));
}

#[test]
fn test_generate_list_with_optional_fields() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "users".to_string(),
            description: None,
            config: true,
            keys: vec!["username".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "username".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "email".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "age".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint8 { range: None },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check key field is non-optional
    assert!(content.contains("pub username: String,"));

    // Check optional fields
    assert!(content.contains("pub email: Option<String>,"));
    assert!(content.contains("pub age: Option<u8>,"));

    // Check skip_serializing_if for optional fields
    assert!(content.contains("skip_serializing_if = \"Option::is_none\""));
}

#[test]
fn test_generate_list_as_container_field() {
    use crate::parser::{Container, DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "system".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::List(List {
                name: "users".to_string(),
                description: Some("System users".to_string()),
                config: true,
                keys: vec!["name".to_string()],
                children: vec![DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                })],
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check container struct
    assert!(content.contains("pub struct System {"));

    // Check list field in container uses Vec
    assert!(content.contains("pub users: Vec<User>,"));
    assert!(content.contains("#[serde(rename = \"users\")]"));

    // Check list item struct
    assert!(content.contains("pub struct User {"));
    assert!(content.contains("/// System users"));
}

#[test]
fn test_generate_nested_list() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "interfaces".to_string(),
            description: None,
            config: true,
            keys: vec!["name".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::List(List {
                    name: "addresses".to_string(),
                    description: Some("IP addresses".to_string()),
                    config: true,
                    keys: vec!["ip".to_string()],
                    children: vec![DataNode::Leaf(Leaf {
                        name: "ip".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check parent list
    assert!(content.contains("pub struct Interface {"));

    // Check nested list field uses Vec
    assert!(content.contains("pub addresses: Vec<Addresse>,"));

    // Check nested list struct
    assert!(content.contains("pub struct Addresse {"));
    assert!(content.contains("/// IP addresses"));
}

#[test]
fn test_list_key_field_always_non_optional() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    // Create a list where the key field is marked as non-mandatory in YANG
    // (which shouldn't happen, but we want to ensure keys are always non-optional)
    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "items".to_string(),
            description: None,
            config: true,
            keys: vec!["id".to_string()],
            children: vec![DataNode::Leaf(Leaf {
                name: "id".to_string(),
                description: None,
                type_spec: TypeSpec::Uint32 { range: None },
                mandatory: false, // Even if marked as non-mandatory
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Key field should still be non-optional
    assert!(content.contains("pub id: u32,"));
    assert!(!content.contains("pub id: Option<u32>"));
}

#[test]
fn test_generate_simple_choice() {
    use crate::parser::{Case, Choice, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "address-type".to_string(),
            description: Some("Address type selection".to_string()),
            mandatory: false,
            cases: vec![
                Case {
                    name: "ipv4".to_string(),
                    description: Some("IPv4 address".to_string()),
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "ipv4-address".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
                Case {
                    name: "ipv6".to_string(),
                    description: Some("IPv6 address".to_string()),
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "ipv6-address".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum AddressType {"));

    // Check rustdoc comment
    assert!(content.contains("/// Address type selection"));

    // Check derive attributes
    assert!(content.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    // Check serde rename_all attribute
    assert!(content.contains("#[serde(rename_all = \"kebab-case\")]"));

    // Check variants with tuple types (single leaf cases)
    assert!(content.contains("Ipv4(String)"));
    assert!(content.contains("Ipv6(String)"));

    // Check case rustdoc comments
    assert!(content.contains("/// IPv4 address"));
    assert!(content.contains("/// IPv6 address"));
}

#[test]
fn test_generate_choice_with_multiple_fields_per_case() {
    use crate::parser::{Case, Choice, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "transport".to_string(),
            description: Some("Transport protocol".to_string()),
            mandatory: true,
            cases: vec![
                Case {
                    name: "tcp".to_string(),
                    description: Some("TCP transport".to_string()),
                    data_nodes: vec![
                        DataNode::Leaf(Leaf {
                            name: "tcp-port".to_string(),
                            description: None,
                            type_spec: TypeSpec::Uint16 { range: None },
                            mandatory: true,
                            default: None,
                            config: true,
                        }),
                        DataNode::Leaf(Leaf {
                            name: "tcp-timeout".to_string(),
                            description: None,
                            type_spec: TypeSpec::Uint32 { range: None },
                            mandatory: false,
                            default: None,
                            config: true,
                        }),
                    ],
                },
                Case {
                    name: "udp".to_string(),
                    description: Some("UDP transport".to_string()),
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "udp-port".to_string(),
                        description: None,
                        type_spec: TypeSpec::Uint16 { range: None },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum Transport {"));

    // Check variants with struct types (multiple fields)
    assert!(content.contains("Tcp(TcpData)"));
    assert!(content.contains("Udp(u16)"));

    // Check case struct definition for TCP
    assert!(content.contains("pub struct TcpData {"));
    assert!(content.contains("pub tcp_port: u16,"));
    assert!(content.contains("pub tcp_timeout: Option<u32>,"));

    // Check serde attributes
    assert!(content.contains("#[serde(rename_all = \"kebab-case\")]"));
}

#[test]
fn test_generate_choice_with_empty_case() {
    use crate::parser::{Case, Choice, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "mode".to_string(),
            description: None,
            mandatory: false,
            cases: vec![
                Case {
                    name: "automatic".to_string(),
                    description: Some("Automatic mode".to_string()),
                    data_nodes: vec![],
                },
                Case {
                    name: "manual".to_string(),
                    description: Some("Manual mode".to_string()),
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "value".to_string(),
                        description: None,
                        type_spec: TypeSpec::Uint32 { range: None },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum Mode {"));

    // Check unit variant for empty case
    assert!(content.contains("Automatic,"));

    // Check tuple variant for single-field case
    assert!(content.contains("Manual(u32)"));
}

#[test]
fn test_generate_choice_with_nested_container() {
    use crate::parser::{Case, Choice, Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "config-type".to_string(),
            description: Some("Configuration type".to_string()),
            mandatory: false,
            cases: vec![Case {
                name: "advanced".to_string(),
                description: Some("Advanced configuration".to_string()),
                data_nodes: vec![DataNode::Container(Container {
                    name: "advanced-config".to_string(),
                    description: Some("Advanced settings".to_string()),
                    config: true,
                    mandatory: true,
                    children: vec![DataNode::Leaf(Leaf {
                        name: "setting".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                })],
            }],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum ConfigType {"));

    // Check variant with struct type (complex nested type)
    assert!(content.contains("Advanced(AdvancedData)"));

    // Check case struct definition
    assert!(content.contains("pub struct AdvancedData {"));
    assert!(content.contains("pub advanced_config: AdvancedConfig,"));

    // Check nested container struct
    assert!(content.contains("pub struct AdvancedConfig {"));
    assert!(content.contains("/// Advanced settings"));
    assert!(content.contains("pub setting: String,"));
}

#[test]
fn test_generate_choice_as_container_field() {
    use crate::parser::{Case, Choice, Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Choice(Choice {
                    name: "address-family".to_string(),
                    description: Some("Address family selection".to_string()),
                    mandatory: false,
                    cases: vec![
                        Case {
                            name: "ipv4".to_string(),
                            description: None,
                            data_nodes: vec![DataNode::Leaf(Leaf {
                                name: "ipv4-addr".to_string(),
                                description: None,
                                type_spec: TypeSpec::String {
                                    length: None,
                                    pattern: None,
                                },
                                mandatory: true,
                                default: None,
                                config: true,
                            })],
                        },
                        Case {
                            name: "ipv6".to_string(),
                            description: None,
                            data_nodes: vec![DataNode::Leaf(Leaf {
                                name: "ipv6-addr".to_string(),
                                description: None,
                                type_spec: TypeSpec::String {
                                    length: None,
                                    pattern: None,
                                },
                                mandatory: true,
                                default: None,
                                config: true,
                            })],
                        },
                    ],
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check container struct
    assert!(content.contains("pub struct Interface {"));

    // Check choice field in container (optional)
    assert!(content.contains("pub address_family: Option<AddressFamily>,"));
    assert!(content.contains("#[serde(rename = \"address-family\""));
    assert!(content.contains("skip_serializing_if = \"Option::is_none\""));

    // Check choice enum definition
    assert!(content.contains("pub enum AddressFamily {"));
    assert!(content.contains("#[serde(rename_all = \"kebab-case\")]"));
    assert!(content.contains("Ipv4(String)"));
    assert!(content.contains("Ipv6(String)"));
}

#[test]
fn test_generate_mandatory_choice_as_container_field() {
    use crate::parser::{Case, Choice, Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Choice(Choice {
                name: "protocol".to_string(),
                description: Some("Protocol selection".to_string()),
                mandatory: true,
                cases: vec![
                    Case {
                        name: "http".to_string(),
                        description: None,
                        data_nodes: vec![DataNode::Leaf(Leaf {
                            name: "http-port".to_string(),
                            description: None,
                            type_spec: TypeSpec::Uint16 { range: None },
                            mandatory: true,
                            default: None,
                            config: true,
                        })],
                    },
                    Case {
                        name: "https".to_string(),
                        description: None,
                        data_nodes: vec![DataNode::Leaf(Leaf {
                            name: "https-port".to_string(),
                            description: None,
                            type_spec: TypeSpec::Uint16 { range: None },
                            mandatory: true,
                            default: None,
                            config: true,
                        })],
                    },
                ],
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check container struct
    assert!(content.contains("pub struct Config {"));

    // Check mandatory choice field (non-optional)
    assert!(content.contains("pub protocol: Protocol,"));
    assert!(!content.contains("pub protocol: Option<Protocol>"));

    // Check choice enum definition
    assert!(content.contains("pub enum Protocol {"));
}

#[test]
fn test_generate_choice_with_nested_list() {
    use crate::parser::{Case, Choice, DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "data-source".to_string(),
            description: Some("Data source selection".to_string()),
            mandatory: false,
            cases: vec![Case {
                name: "database".to_string(),
                description: Some("Database source".to_string()),
                data_nodes: vec![DataNode::List(List {
                    name: "servers".to_string(),
                    description: Some("Database servers".to_string()),
                    config: true,
                    keys: vec!["host".to_string()],
                    children: vec![DataNode::Leaf(Leaf {
                        name: "host".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                })],
            }],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check enum definition
    assert!(content.contains("pub enum DataSource {"));

    // Check variant with struct type (complex nested type)
    assert!(content.contains("Database(DatabaseData)"));

    // Check case struct definition
    assert!(content.contains("pub struct DatabaseData {"));
    assert!(content.contains("pub servers: Vec<Server>,"));

    // Check nested list struct
    assert!(content.contains("pub struct Server {"));
    assert!(content.contains("/// Database servers"));
}

#[test]
fn test_generate_validated_int_with_range() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "port".to_string(),
                description: Some("Port number".to_string()),
                type_spec: TypeSpec::Uint16 {
                    range: Some(RangeConstraint::new(vec![Range::new(1, 65535)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check ValidationError is generated
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("OutOfRange"));

    // Check validated type is generated
    assert!(content.contains("pub struct ValidatedUint16Id"));
    assert!(content.contains("value: u16"));
    assert!(content.contains("pub fn new(value: u16) -> Result<Self, ValidationError>"));
    assert!(content.contains("pub fn value(&self) -> u16"));

    // Check TryFrom implementation
    assert!(content.contains("impl TryFrom<u16> for ValidatedUint16Id"));

    // Check Serialize/Deserialize implementations
    assert!(content.contains("impl serde::Serialize for ValidatedUint16Id"));
    assert!(content.contains("impl<'de> serde::Deserialize<'de> for ValidatedUint16Id"));

    // Check field uses validated type
    assert!(content.contains("pub port: ValidatedUint16Id"));
}

#[test]
fn test_generate_validated_string_with_length() {
    use crate::parser::{Container, DataNode, Leaf, LengthConstraint, LengthRange, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "user".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "username".to_string(),
                description: Some("Username".to_string()),
                type_spec: TypeSpec::String {
                    length: Some(LengthConstraint::new(vec![LengthRange::new(3, 20)])),
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check ValidationError is generated
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("InvalidLength"));

    // Check validated type is generated
    assert!(content.contains("pub struct ValidatedStringId"));
    assert!(content.contains("value: String"));
    assert!(content.contains("pub fn new(value: String) -> Result<Self, ValidationError>"));
    assert!(content.contains("pub fn value(&self) -> &str"));

    // Check length validation logic
    assert!(content.contains("let length = value.len() as u64"));
    assert!(content.contains("(3..=20).contains(&length)"));

    // Check field uses validated type
    assert!(content.contains("pub username: ValidatedStringId"));
}

#[test]
fn test_generate_validated_string_with_pattern() {
    use crate::parser::{Container, DataNode, Leaf, PatternConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "email".to_string(),
                description: Some("Email address".to_string()),
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: Some(PatternConstraint::new("[a-z]+@[a-z]+\\.[a-z]+".to_string())),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check ValidationError is generated
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("InvalidPattern"));

    // Check validated type is generated
    assert!(content.contains("pub struct ValidatedStringId"));

    // Check pattern validation logic
    assert!(content.contains("regex::Regex::new"));
    assert!(content.contains("pattern.is_match"));

    // Check field uses validated type
    assert!(content.contains("pub email: ValidatedStringId"));
}

#[test]
fn test_generate_optional_validated_type() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "timeout".to_string(),
                description: Some("Timeout in seconds".to_string()),
                type_spec: TypeSpec::Uint32 {
                    range: Some(RangeConstraint::new(vec![Range::new(1, 3600)])),
                },
                mandatory: false,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check validated type is generated
    assert!(content.contains("pub struct ValidatedUint32Id"));

    // Check field uses Option<ValidatedType>
    assert!(content.contains("pub timeout: Option<ValidatedUint32Id"));
}

#[test]
fn test_validation_disabled_uses_base_types() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "port".to_string(),
                description: Some("Port number".to_string()),
                type_spec: TypeSpec::Uint16 {
                    range: Some(RangeConstraint::new(vec![Range::new(1, 65535)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check ValidationError is NOT generated
    assert!(!content.contains("pub enum ValidationError"));

    // Check validated type is NOT generated
    assert!(!content.contains("pub struct ValidatedUint16Id"));

    // Check field uses base type
    assert!(content.contains("pub port: u16,"));
}

#[test]
fn test_generate_multiple_validated_types() {
    use crate::parser::{
        Container, DataNode, Leaf, LengthConstraint, LengthRange, Range, RangeConstraint, TypeSpec,
    };

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "server".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "port".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint16 {
                        range: Some(RangeConstraint::new(vec![Range::new(1, 65535)])),
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "hostname".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: Some(LengthConstraint::new(vec![LengthRange::new(1, 255)])),
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check both validated types are generated
    assert!(content.contains("pub struct ValidatedUint16Id"));
    assert!(content.contains("pub struct ValidatedStringId"));

    // Check both fields use validated types
    assert!(content.contains("pub port: ValidatedUint16Id"));
    assert!(content.contains("pub hostname: ValidatedStringId"));
}

#[test]
fn test_validation_error_display_implementation() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};

    let config = GeneratorConfig {
        enable_validation: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "value".to_string(),
                description: None,
                type_spec: TypeSpec::Int32 {
                    range: Some(RangeConstraint::new(vec![Range::new(0, 100)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check Display implementation
    assert!(content.contains("impl std::fmt::Display for ValidationError"));
    assert!(content.contains("fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result"));

    // Check Error trait implementation
    assert!(content.contains("impl std::error::Error for ValidationError"));
}

// Tests for JSON serialization and RESTCONF compliance (Task 9.1)

#[test]
fn test_serde_rename_attribute_for_yang_names() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface-config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "interface-name".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check that serde rename attribute preserves YANG kebab-case naming
    assert!(content.contains(r#"#[serde(rename = "interface-name")]"#));
    // Check that Rust field uses snake_case
    assert!(content.contains("pub interface_name: String"));
}

#[test]
fn test_optional_field_skip_serializing_if_none() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "required-field".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "optional-field".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check that mandatory field does NOT have skip_serializing_if
    assert!(content.contains(r#"#[serde(rename = "required-field")]"#));
    assert!(!content.contains(r#"#[serde(rename = "required-field", skip_serializing_if"#));

    // Check that optional field HAS skip_serializing_if
    assert!(content.contains(
        r#"#[serde(rename = "optional-field", skip_serializing_if = "Option::is_none")]"#
    ));
    assert!(content.contains("pub optional_field: Option<String>"));
}

#[test]
fn test_namespace_prefix_disabled_by_default() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig {
        enable_namespace_prefixes: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test-module".to_string(),
        namespace: "urn:test:module".to_string(),
        prefix: "tm".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "field-name".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check that field name does NOT have namespace prefix
    assert!(content.contains(r#"#[serde(rename = "field-name")]"#));
    assert!(!content.contains(r#"#[serde(rename = "tm:field-name")]"#));
}

#[test]
fn test_namespace_prefix_enabled() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig {
        enable_namespace_prefixes: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test-module".to_string(),
        namespace: "urn:test:module".to_string(),
        prefix: "tm".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "field-name".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check that field name HAS namespace prefix
    assert!(content.contains(r#"#[serde(rename = "tm:field-name")]"#));
    assert!(content.contains("pub field_name: String"));
}

#[test]
fn test_namespace_prefix_on_nested_containers() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig {
        enable_namespace_prefixes: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "outer".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Container(Container {
                name: "inner".to_string(),
                description: None,
                config: true,
                mandatory: true,
                children: vec![DataNode::Leaf(Leaf {
                    name: "value".to_string(),
                    description: None,
                    type_spec: TypeSpec::Int32 { range: None },
                    mandatory: true,
                    default: None,
                    config: true,
                })],
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check that nested container field has namespace prefix
    assert!(content.contains(r#"#[serde(rename = "t:inner")]"#));
    // Check that leaf in nested container has namespace prefix
    assert!(content.contains(r#"#[serde(rename = "t:value")]"#));
}

#[test]
fn test_namespace_prefix_on_list_fields() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig {
        enable_namespace_prefixes: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "interfaces".to_string(),
            description: None,
            config: true,
            keys: vec!["name".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "enabled".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check that list item fields have namespace prefix
    assert!(content.contains(r#"#[serde(rename = "t:name")]"#));
    assert!(content.contains(r#"#[serde(rename = "t:enabled")]"#));
}

#[test]
fn test_choice_enum_kebab_case_serialization() {
    use crate::parser::{Case, Choice, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "address-type".to_string(),
            description: None,
            mandatory: false,
            cases: vec![
                Case {
                    name: "ipv4-address".to_string(),
                    description: None,
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "ipv4".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
                Case {
                    name: "ipv6-address".to_string(),
                    description: None,
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "ipv6".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check that choice enum has kebab-case serialization
    assert!(content.contains(r#"#[serde(rename_all = "kebab-case")]"#));
    assert!(content.contains("pub enum AddressType"));
}

#[test]
fn test_generated_code_compiles_and_serializes() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test_serialization".to_string(),
        enable_namespace_prefixes: false,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: Some("Test configuration".to_string()),
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "device-name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "enabled".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "description".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let file_path = output_dir.join("test_serialization.rs");
    let content = fs::read_to_string(&file_path).unwrap();

    // Verify the generated code has proper serde attributes
    assert!(content.contains(r#"#[serde(rename = "device-name")]"#));
    assert!(content.contains(r#"#[serde(rename = "enabled")]"#));
    assert!(content
        .contains(r#"#[serde(rename = "description", skip_serializing_if = "Option::is_none")]"#));

    // Verify struct definition
    assert!(content.contains("pub struct Config"));
    assert!(content.contains("pub device_name: String"));
    assert!(content.contains("pub enabled: bool"));
    assert!(content.contains("pub description: Option<String>"));
}

#[test]
fn test_generated_code_with_namespace_prefix_compiles() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};
    use std::fs;
    use tempfile::TempDir;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test_namespace".to_string(),
        enable_namespace_prefixes: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "interface-module".to_string(),
        namespace: "urn:ietf:params:xml:ns:yang:interface".to_string(),
        prefix: "if".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "name".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let file_path = output_dir.join("test_namespace.rs");
    let content = fs::read_to_string(&file_path).unwrap();

    // Verify the generated code has namespace-prefixed field names
    assert!(content.contains(r#"#[serde(rename = "if:name")]"#));
    assert!(content.contains("pub struct Interface"));
    assert!(content.contains("pub name: String"));
}

// Tests for JSON serialization behavior (Task 9.2)

#[test]
fn test_simple_struct_json_serialization() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "simple-config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "enabled".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify the generated code has correct serde attributes
    assert!(content.contains(r#"#[serde(rename = "name")]"#));
    assert!(content.contains(r#"#[serde(rename = "enabled")]"#));
    assert!(content.contains("pub struct SimpleConfig"));
    assert!(content.contains("pub name: String"));
    assert!(content.contains("pub enabled: bool"));
}

#[test]
fn test_field_name_conversion_snake_case_to_kebab_case() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "device-name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "max-connections".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint32 { range: None },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "is-active".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify YANG kebab-case names are preserved in serde rename
    assert!(content.contains(r#"#[serde(rename = "device-name")]"#));
    assert!(content.contains(r#"#[serde(rename = "max-connections")]"#));
    assert!(content.contains(r#"#[serde(rename = "is-active")]"#));

    // Verify Rust field names use snake_case
    assert!(content.contains("pub device_name: String"));
    assert!(content.contains("pub max_connections: u32"));
    assert!(content.contains("pub is_active: bool"));
}

#[test]
fn test_optional_field_skip_serializing_if_attribute() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "required-name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "optional-description".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "optional-count".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint32 { range: None },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify mandatory field does NOT have skip_serializing_if
    assert!(content.contains(r#"#[serde(rename = "required-name")]"#));
    let required_field_line = content
        .lines()
        .find(|line| line.contains(r#"rename = "required-name""#))
        .unwrap();
    assert!(!required_field_line.contains("skip_serializing_if"));

    // Verify optional fields HAVE skip_serializing_if
    assert!(content.contains(
        r#"#[serde(rename = "optional-description", skip_serializing_if = "Option::is_none")]"#
    ));
    assert!(content.contains(
        r#"#[serde(rename = "optional-count", skip_serializing_if = "Option::is_none")]"#
    ));

    // Verify field types
    assert!(content.contains("pub required_name: String"));
    assert!(content.contains("pub optional_description: Option<String>"));
    assert!(content.contains("pub optional_count: Option<u32>"));
}

#[test]
fn test_namespace_prefix_in_json_field_names() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    // Test with namespace prefixes enabled
    let config = GeneratorConfig {
        enable_namespace_prefixes: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "interface-module".to_string(),
        namespace: "urn:ietf:params:xml:ns:yang:interface".to_string(),
        prefix: "if".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "interface".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "type".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify namespace prefix is included in JSON field names
    assert!(content.contains(r#"#[serde(rename = "if:name")]"#));
    assert!(content.contains(r#"#[serde(rename = "if:type")]"#));

    // Verify Rust field names don't have prefix
    assert!(content.contains("pub name: String"));
    assert!(content.contains("pub type_: String")); // 'type' is a Rust keyword, should be escaped
}

#[test]
fn test_namespace_prefix_disabled() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    // Test with namespace prefixes disabled
    let config = GeneratorConfig {
        enable_namespace_prefixes: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test-module".to_string(),
        namespace: "urn:test:module".to_string(),
        prefix: "tm".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "field-name".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify namespace prefix is NOT included
    assert!(content.contains(r#"#[serde(rename = "field-name")]"#));
    assert!(!content.contains(r#"#[serde(rename = "tm:field-name")]"#));
}

#[test]
fn test_nested_container_json_serialization_attributes() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig {
        enable_namespace_prefixes: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "outer".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "outer-field".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Container(Container {
                    name: "inner".to_string(),
                    description: None,
                    config: true,
                    mandatory: false,
                    children: vec![DataNode::Leaf(Leaf {
                        name: "inner-field".to_string(),
                        description: None,
                        type_spec: TypeSpec::Int32 { range: None },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify outer container fields have namespace prefix
    assert!(content.contains(r#"#[serde(rename = "t:outer-field")]"#));
    assert!(content.contains(r#"rename = "t:inner""#));

    // Verify inner container fields have namespace prefix
    assert!(content.contains(r#"#[serde(rename = "t:inner-field")]"#));

    // Verify optional nested container has skip_serializing_if
    let inner_field_line = content
        .lines()
        .find(|line| line.contains(r#"rename = "t:inner""#))
        .unwrap();
    assert!(inner_field_line.contains("skip_serializing_if"));
}

#[test]
fn test_list_json_serialization_attributes() {
    use crate::parser::{DataNode, Leaf, List, TypeSpec};

    let config = GeneratorConfig {
        enable_namespace_prefixes: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::List(List {
            name: "interfaces".to_string(),
            description: None,
            config: true,
            keys: vec!["name".to_string()],
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "name".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "mtu".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint16 { range: None },
                    mandatory: false,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify list item fields have namespace prefix
    assert!(content.contains(r#"rename = "t:name""#));
    assert!(content.contains(r#"rename = "t:mtu""#));

    // Verify key field does NOT have skip_serializing_if
    let name_field_line = content
        .lines()
        .find(|line| line.contains(r#"rename = "t:name""#))
        .unwrap();
    assert!(!name_field_line.contains("skip_serializing_if"));

    // Verify optional non-key field HAS skip_serializing_if
    assert!(content.contains(r#"skip_serializing_if = "Option::is_none""#));
    let mtu_field_line = content
        .lines()
        .find(|line| line.contains(r#"rename = "t:mtu""#))
        .unwrap();
    assert!(mtu_field_line.contains("skip_serializing_if"));
}

#[test]
fn test_choice_enum_json_serialization_attributes() {
    use crate::parser::{Case, Choice, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Choice(Choice {
            name: "address-type".to_string(),
            description: None,
            mandatory: false,
            cases: vec![
                Case {
                    name: "ipv4-address".to_string(),
                    description: None,
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "ipv4".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
                Case {
                    name: "ipv6-address".to_string(),
                    description: None,
                    data_nodes: vec![DataNode::Leaf(Leaf {
                        name: "ipv6".to_string(),
                        description: None,
                        type_spec: TypeSpec::String {
                            length: None,
                            pattern: None,
                        },
                        mandatory: true,
                        default: None,
                        config: true,
                    })],
                },
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify choice enum has kebab-case serialization
    assert!(content.contains(r#"#[serde(rename_all = "kebab-case")]"#));
    assert!(content.contains("pub enum AddressType"));

    // Verify enum variants are in PascalCase
    assert!(content.contains("Ipv4Address"));
    assert!(content.contains("Ipv6Address"));
}

#[test]
fn test_multiple_data_types_json_serialization() {
    use crate::parser::{Container, DataNode, Leaf, TypeSpec};

    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![
                DataNode::Leaf(Leaf {
                    name: "string-field".to_string(),
                    description: None,
                    type_spec: TypeSpec::String {
                        length: None,
                        pattern: None,
                    },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "int8-field".to_string(),
                    description: None,
                    type_spec: TypeSpec::Int8 { range: None },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "uint32-field".to_string(),
                    description: None,
                    type_spec: TypeSpec::Uint32 { range: None },
                    mandatory: true,
                    default: None,
                    config: true,
                }),
                DataNode::Leaf(Leaf {
                    name: "bool-field".to_string(),
                    description: None,
                    type_spec: TypeSpec::Boolean,
                    mandatory: true,
                    default: None,
                    config: true,
                }),
            ],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Verify all fields have correct serde rename attributes
    assert!(content.contains(r#"#[serde(rename = "string-field")]"#));
    assert!(content.contains(r#"#[serde(rename = "int8-field")]"#));
    assert!(content.contains(r#"#[serde(rename = "uint32-field")]"#));
    assert!(content.contains(r#"#[serde(rename = "bool-field")]"#));

    // Verify field types
    assert!(content.contains("pub string_field: String"));
    assert!(content.contains("pub int8_field: i8"));
    assert!(content.contains("pub uint32_field: u32"));
    assert!(content.contains("pub bool_field: bool"));
}

#[test]
fn test_deserialization_validation_works_for_range_constraints() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test_validation".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "port".to_string(),
                description: Some("Port number (1-65535)".to_string()),
                type_spec: TypeSpec::Uint16 {
                    range: Some(RangeConstraint::new(vec![Range::new(1, 65535)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("test_validation.rs")).unwrap();

    // Verify the generated code includes:
    // 1. ValidationError type
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("OutOfRange"));

    // 2. Validated type with new() method
    assert!(content.contains("pub fn new(value: u16) -> Result<Self, ValidationError>"));

    // 3. Validation logic
    assert!(content.contains("(1..=65535).contains(&value)"));

    // 4. Deserialize implementation that calls new()
    assert!(content.contains("impl<'de> serde::Deserialize<'de> for ValidatedUint16Id"));
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));

    // 5. Error includes value and constraint
    assert!(content.contains("value: value.to_string()"));
    assert!(content.contains(r#"constraint: "1..65535".to_string()"#));
}

#[test]
fn test_deserialization_validation_works_for_length_constraints() {
    use crate::parser::{Container, DataNode, Leaf, LengthConstraint, LengthRange, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test_length".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "user".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "username".to_string(),
                description: Some("Username (3-20 chars)".to_string()),
                type_spec: TypeSpec::String {
                    length: Some(LengthConstraint::new(vec![LengthRange::new(3, 20)])),
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("test_length.rs")).unwrap();

    // Verify the generated code includes:
    // 1. ValidationError type with InvalidLength variant
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("InvalidLength"));

    // 2. Length validation logic
    assert!(content.contains("let length = value.len() as u64"));
    assert!(content.contains("(3..=20).contains(&length)"));

    // 3. Deserialize implementation
    assert!(content.contains("impl<'de> serde::Deserialize<'de> for ValidatedStringId"));
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));

    // 4. Error includes value and constraint
    assert!(content.contains("value: value.clone()"));
    assert!(content.contains(r#"constraint: "3..20".to_string()"#));
}

#[test]
fn test_deserialization_validation_works_for_pattern_constraints() {
    use crate::parser::{Container, DataNode, Leaf, PatternConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test_pattern".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "email".to_string(),
                description: Some("Email address".to_string()),
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: Some(PatternConstraint::new("[a-z]+@[a-z]+\\.[a-z]+".to_string())),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("test_pattern.rs")).unwrap();

    // Verify the generated code includes:
    // 1. ValidationError type with InvalidPattern variant
    assert!(content.contains("pub enum ValidationError"));
    assert!(content.contains("InvalidPattern"));

    // 2. Pattern validation logic
    assert!(content.contains("regex::Regex::new"));
    assert!(content.contains("pattern.is_match"));

    // 3. Deserialize implementation
    assert!(content.contains("impl<'de> serde::Deserialize<'de> for ValidatedStringId"));
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));

    // 4. Error includes value and pattern
    assert!(content.contains("value: value.clone()"));
    assert!(content.contains(r#"pattern: r"[a-z]+@[a-z]+\.[a-z]+".to_string()"#));
}

#[test]
fn test_validation_error_messages_are_descriptive() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test_errors".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "value".to_string(),
                description: None,
                type_spec: TypeSpec::Int32 {
                    range: Some(RangeConstraint::new(vec![Range::new(-100, 100)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("test_errors.rs")).unwrap();

    // Verify Display implementation for ValidationError
    assert!(content.contains("impl std::fmt::Display for ValidationError"));

    // Verify error messages include both value and constraint
    assert!(content
        .contains(r#"write!(f, "Value '{}' is outside allowed range: {}", value, constraint)"#));
    assert!(content.contains(
        r#"write!(f, "Value '{}' has invalid length, expected: {}", value, constraint)"#
    ));
    assert!(
        content.contains(r#"write!(f, "Value '{}' does not match pattern: {}", value, pattern)"#)
    );

    // Verify Error trait implementation
    assert!(content.contains("impl std::error::Error for ValidationError"));
}

// Task 9.5: Unit tests for deserialization validation
// These tests verify that generated code properly validates data during deserialization

#[test]
fn test_range_validation_deserialize_valid_data_succeeds() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "valid_range_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "port".to_string(),
                description: Some("Port number (1-65535)".to_string()),
                type_spec: TypeSpec::Uint16 {
                    range: Some(RangeConstraint::new(vec![Range::new(1, 65535)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("valid_range_test.rs")).unwrap();

    // Verify Deserialize implementation exists and calls validation
    assert!(content.contains("impl<'de> serde::Deserialize<'de> for ValidatedUint16Id"));
    assert!(content.contains("let value = u16::deserialize(deserializer)?;"));
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));

    // Verify validation logic accepts valid values
    assert!(content.contains("(1..=65535).contains(&value)"));
    assert!(content.contains("if valid {"));
    assert!(content.contains("Ok(Self { value })"));
}

#[test]
fn test_range_validation_deserialize_invalid_data_returns_error() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "invalid_range_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "value".to_string(),
                description: None,
                type_spec: TypeSpec::Int32 {
                    range: Some(RangeConstraint::new(vec![Range::new(10, 100)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("invalid_range_test.rs")).unwrap();

    // Verify validation logic rejects invalid values
    assert!(content.contains("if valid {"));
    assert!(content.contains("} else {"));
    assert!(content.contains("Err(ValidationError::OutOfRange {"));

    // Verify error is propagated through deserialize
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));
}

#[test]
fn test_range_validation_error_includes_value_and_constraint() {
    use crate::parser::{Container, DataNode, Leaf, Range, RangeConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "range_error_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "percentage".to_string(),
                description: None,
                type_spec: TypeSpec::Uint8 {
                    range: Some(RangeConstraint::new(vec![Range::new(0, 100)])),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("range_error_test.rs")).unwrap();

    // Verify error includes the violating value
    assert!(content.contains("value: value.to_string()"));

    // Verify error includes the constraint details
    assert!(content.contains(r#"constraint: "0..100".to_string()"#));

    // Verify Display implementation shows both value and constraint
    assert!(content
        .contains(r#"write!(f, "Value '{}' is outside allowed range: {}", value, constraint)"#));
}

#[test]
fn test_length_validation_deserialize_valid_data_succeeds() {
    use crate::parser::{Container, DataNode, Leaf, LengthConstraint, LengthRange, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "valid_length_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "user".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "username".to_string(),
                description: Some("Username (3-20 chars)".to_string()),
                type_spec: TypeSpec::String {
                    length: Some(LengthConstraint::new(vec![LengthRange::new(3, 20)])),
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("valid_length_test.rs")).unwrap();

    // Verify Deserialize implementation exists and calls validation
    assert!(content.contains("impl<'de> serde::Deserialize<'de> for ValidatedStringId"));
    assert!(content.contains("let value = String::deserialize(deserializer)?;"));
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));

    // Verify length validation logic
    assert!(content.contains("let length = value.len() as u64"));
    assert!(content.contains("(3..=20).contains(&length)"));
    assert!(content.contains("if !length_valid {"));
    assert!(content.contains("return Err(ValidationError::InvalidLength {"));
}

#[test]
fn test_length_validation_deserialize_invalid_data_returns_error() {
    use crate::parser::{Container, DataNode, Leaf, LengthConstraint, LengthRange, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "invalid_length_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "code".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: Some(LengthConstraint::new(vec![LengthRange::new(5, 10)])),
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("invalid_length_test.rs")).unwrap();

    // Verify validation rejects invalid lengths
    assert!(content.contains("if !length_valid {"));
    assert!(content.contains("return Err(ValidationError::InvalidLength {"));
    assert!(content.contains("value: value.clone()"));

    // Verify error is propagated through deserialize
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));
}

#[test]
fn test_length_validation_error_includes_value_and_constraint() {
    use crate::parser::{Container, DataNode, Leaf, LengthConstraint, LengthRange, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "length_error_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "data".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "name".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: Some(LengthConstraint::new(vec![LengthRange::new(1, 50)])),
                    pattern: None,
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("length_error_test.rs")).unwrap();

    // Verify error includes the violating value
    assert!(content.contains("value: value.clone()"));

    // Verify error includes the constraint details
    assert!(content.contains(r#"constraint: "1..50".to_string()"#));

    // Verify Display implementation shows both value and constraint
    assert!(content.contains(
        r#"write!(f, "Value '{}' has invalid length, expected: {}", value, constraint)"#
    ));
}

#[test]
fn test_pattern_validation_deserialize_valid_data_succeeds() {
    use crate::parser::{Container, DataNode, Leaf, PatternConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "valid_pattern_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "email".to_string(),
                description: Some("Email address".to_string()),
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: Some(PatternConstraint::new("[a-z]+@[a-z]+\\.[a-z]+".to_string())),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("valid_pattern_test.rs")).unwrap();

    // Verify Deserialize implementation exists and calls validation
    assert!(content.contains("impl<'de> serde::Deserialize<'de> for ValidatedStringId"));
    assert!(content.contains("let value = String::deserialize(deserializer)?;"));
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));

    // Verify pattern validation logic
    assert!(content.contains("regex::Regex::new"));
    assert!(content.contains("pattern.is_match(&value)"));
    assert!(content.contains("if !pattern.is_match(&value) {"));
    assert!(content.contains("return Err(ValidationError::InvalidPattern {"));
}

#[test]
fn test_pattern_validation_deserialize_invalid_data_returns_error() {
    use crate::parser::{Container, DataNode, Leaf, PatternConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "invalid_pattern_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "ipv4".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: Some(PatternConstraint::new(
                        "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}".to_string(),
                    )),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("invalid_pattern_test.rs")).unwrap();

    // Verify validation rejects non-matching patterns
    assert!(content.contains("if !pattern.is_match(&value) {"));
    assert!(content.contains("return Err(ValidationError::InvalidPattern {"));
    assert!(content.contains("value: value.clone()"));

    // Verify error is propagated through deserialize
    assert!(content.contains("Self::new(value).map_err(serde::de::Error::custom)"));
}

#[test]
fn test_pattern_validation_error_includes_value_and_pattern() {
    use crate::parser::{Container, DataNode, Leaf, PatternConstraint, TypeSpec};
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "pattern_error_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "code".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: None,
                    pattern: Some(PatternConstraint::new("[A-Z]{3}-\\d{4}".to_string())),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("pattern_error_test.rs")).unwrap();

    // Verify error includes the violating value
    assert!(content.contains("value: value.clone()"));

    // Verify error includes the pattern
    assert!(content.contains(r#"pattern: r"[A-Z]{3}-\d{4}".to_string()"#));

    // Verify Display implementation shows both value and pattern
    assert!(
        content.contains(r#"write!(f, "Value '{}' does not match pattern: {}", value, pattern)"#)
    );
}

#[test]
fn test_combined_length_and_pattern_validation() {
    use crate::parser::{
        Container, DataNode, Leaf, LengthConstraint, LengthRange, PatternConstraint, TypeSpec,
    };
    use std::fs;

    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "combined_validation_test".to_string(),
        enable_validation: true,
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![DataNode::Container(Container {
            name: "config".to_string(),
            description: None,
            config: true,
            mandatory: false,
            children: vec![DataNode::Leaf(Leaf {
                name: "username".to_string(),
                description: None,
                type_spec: TypeSpec::String {
                    length: Some(LengthConstraint::new(vec![LengthRange::new(3, 15)])),
                    pattern: Some(PatternConstraint::new("[a-z][a-z0-9_]*".to_string())),
                },
                mandatory: true,
                default: None,
                config: true,
            })],
        })],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let content = fs::read_to_string(output_dir.join("combined_validation_test.rs")).unwrap();

    // Verify both length and pattern validation are present
    assert!(content.contains("let length = value.len() as u64"));
    assert!(content.contains("(3..=15).contains(&length)"));
    assert!(content.contains("if !length_valid {"));
    assert!(content.contains("return Err(ValidationError::InvalidLength {"));

    assert!(content.contains("regex::Regex::new"));
    assert!(content.contains("pattern.is_match(&value)"));
    assert!(content.contains("if !pattern.is_match(&value) {"));
    assert!(content.contains("return Err(ValidationError::InvalidPattern {"));

    // Verify both validations happen in sequence (length first, then pattern)
    let length_pos = content.find("let length = value.len()").unwrap();
    let pattern_pos = content.find("regex::Regex::new").unwrap();
    assert!(
        length_pos < pattern_pos,
        "Length validation should come before pattern validation"
    );
}
