//! Unit tests for code generator module.

use std::path::PathBuf;
use tempfile::TempDir;

use crate::parser::{YangModule, YangVersion};

use super::*;

#[test]
fn test_generate_creates_generated_code() {
    let config = GeneratorConfig {
        output_dir: PathBuf::from("test_output"),
        module_name: "test_module".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test-module".to_string(),
        namespace: "urn:test:module".to_string(),
        prefix: "test".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let result = generator.generate(&module);
    assert!(result.is_ok());

    let generated = result.unwrap();
    assert_eq!(generated.file_count(), 1);
    assert!(generated.total_size() > 0);
}

#[test]
fn test_generated_file_has_correct_path() {
    let config = GeneratorConfig {
        output_dir: PathBuf::from("output"),
        module_name: "my_module".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let file = &generated.files[0];

    assert_eq!(file.path, PathBuf::from("output/my_module.rs"));
}

#[test]
fn test_generated_content_has_header() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "example-module".to_string(),
        namespace: "urn:example:module".to_string(),
        prefix: "ex".to_string(),
        yang_version: Some(YangVersion::V1_0),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for header comments
    assert!(content.contains("This file is automatically generated by rustconf"));
    assert!(content.contains("DO NOT EDIT MANUALLY"));
    assert!(content.contains("Source YANG module: example-module"));
    assert!(content.contains("Namespace: urn:example:module"));
    assert!(content.contains("Prefix: ex"));
    assert!(content.contains("YANG version: 1.0"));
    assert!(content.contains("Generated at:"));
}

#[test]
fn test_generated_content_has_use_statements() {
    let config = GeneratorConfig {
        enable_xml: false,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for serde use statement
    assert!(content.contains("use serde::{Deserialize, Serialize}"));
}

#[test]
fn test_generated_content_has_xml_use_when_enabled() {
    let config = GeneratorConfig {
        enable_xml: true,
        ..Default::default()
    };
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for XML use statement with feature gate
    assert!(content.contains("#[cfg(feature = \"xml\")]"));
    assert!(content.contains("use serde_xml_rs"));
}

#[test]
fn test_generated_content_has_module_documentation() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "interface-config".to_string(),
        namespace: "urn:ietf:params:xml:ns:yang:interface".to_string(),
        prefix: "if".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let content = &generated.files[0].content;

    // Check for module documentation
    assert!(content.contains("//! Generated Rust bindings for YANG module: interface-config"));
    assert!(content.contains("//! Namespace: urn:ietf:params:xml:ns:yang:interface"));
}

#[test]
fn test_write_files_creates_output_directory() {
    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("generated");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "test".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    let result = generator.write_files(&generated);

    assert!(result.is_ok());
    assert!(output_dir.exists());
    assert!(output_dir.join("test.rs").exists());
}

#[test]
fn test_write_files_writes_correct_content() {
    let temp_dir = TempDir::new().unwrap();
    let output_dir = temp_dir.path().join("output");

    let config = GeneratorConfig {
        output_dir: output_dir.clone(),
        module_name: "example".to_string(),
        ..Default::default()
    };

    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "example".to_string(),
        namespace: "urn:example".to_string(),
        prefix: "ex".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    generator.write_files(&generated).unwrap();

    let file_path = output_dir.join("example.rs");
    let written_content = std::fs::read_to_string(file_path).unwrap();

    assert_eq!(written_content, generated.files[0].content);
}

#[test]
fn test_generated_code_file_count() {
    let generated = GeneratedCode {
        files: vec![
            GeneratedFile {
                path: PathBuf::from("file1.rs"),
                content: "content1".to_string(),
            },
            GeneratedFile {
                path: PathBuf::from("file2.rs"),
                content: "content2".to_string(),
            },
        ],
    };

    assert_eq!(generated.file_count(), 2);
}

#[test]
fn test_generated_code_total_size() {
    let generated = GeneratedCode {
        files: vec![
            GeneratedFile {
                path: PathBuf::from("file1.rs"),
                content: "hello".to_string(), // 5 bytes
            },
            GeneratedFile {
                path: PathBuf::from("file2.rs"),
                content: "world!".to_string(), // 6 bytes
            },
        ],
    };

    assert_eq!(generated.total_size(), 11);
}

#[test]
fn test_header_includes_yang_version_when_present() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module_v1_0 = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: Some(YangVersion::V1_0),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module_v1_0).unwrap();
    assert!(generated.files[0].content.contains("YANG version: 1.0"));

    let module_v1_1 = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: Some(YangVersion::V1_1),
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module_v1_1).unwrap();
    assert!(generated.files[0].content.contains("YANG version: 1.1"));
}

#[test]
fn test_header_omits_yang_version_when_absent() {
    let config = GeneratorConfig::default();
    let generator = CodeGenerator::new(config);

    let module = YangModule {
        name: "test".to_string(),
        namespace: "urn:test".to_string(),
        prefix: "t".to_string(),
        yang_version: None,
        imports: vec![],
        typedefs: vec![],
        groupings: vec![],
        data_nodes: vec![],
        rpcs: vec![],
        notifications: vec![],
    };

    let generated = generator.generate(&module).unwrap();
    assert!(!generated.files[0].content.contains("YANG version:"));
}
