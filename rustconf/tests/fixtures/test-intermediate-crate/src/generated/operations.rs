// This file is automatically generated by rustconf.
// DO NOT EDIT MANUALLY.

use rustconf_runtime::{RestconfClient, HttpTransport, HttpRequest, HttpMethod, RpcError};
use serde::{Deserialize, Serialize};
use super::types::*;

/// RESTCONF operations.
pub mod operations {
    use super::*;

    /// Percent-encode a string for use in URLs.
    ///
    /// This function encodes special characters according to RFC 3986.
    #[allow(dead_code)]
    fn percent_encode(s: &str) -> String {
        s.chars()
            .map(|c| match c {
                'A'..='Z' | 'a'..='z' | '0'..='9' | '-' | '_' | '.' | '~' => c.to_string(),
                _ => format!("%{:02X}", c as u8),
            })
            .collect()
    }

    /// Input parameters for restart-device RPC.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct RestartDeviceInput {
        /// Force restart without graceful shutdown
        #[serde(rename = "force", skip_serializing_if = "Option::is_none")]
        pub force: Option<bool>,
    }

    /// Output result for restart-device RPC.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct RestartDeviceOutput {
        /// Whether the restart was successful
        #[serde(rename = "success", skip_serializing_if = "Option::is_none")]
        pub success: Option<bool>,
        /// Status message
        #[serde(rename = "message", skip_serializing_if = "Option::is_none")]
        pub message: Option<String>,
    }

    /// Restart the device
    ///
    /// # Arguments
    ///
    /// * `client` - The RestconfClient to use for executing the RPC request
    /// * `input` - The input parameters for the restart-device operation
    ///
    /// # Returns
    ///
    /// Returns `Ok(RestartDeviceOutput)` on success, containing the operation result.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Input serialization fails (`RpcError::SerializationError`)
    /// - The HTTP request fails (`RpcError::TransportError`)
    /// - The server returns an error status:
    ///   - 400: `RpcError::InvalidInput`
    ///   - 401/403: `RpcError::Unauthorized`
    ///   - 404: `RpcError::NotFound`
    ///   - 500-599: `RpcError::ServerError`
    /// - Response deserialization fails (`RpcError::DeserializationError`)
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// use test_device::*;
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), RpcError> {
    ///     // Create a transport adapter
    ///     let transport = reqwest_adapter::ReqwestTransport::new();
    ///
    ///     // Create a client for the RESTCONF server
    ///     let client = RestconfClient::new(
    ///         "https://device.example.com",
    ///         transport
    ///     )?;
    ///
    ///     // Prepare input parameters
    ///     let input = RestartDeviceInput {
    ///         // Set input fields here
    ///         // ...
    ///     };
    ///
    ///     // Execute the RPC operation
    ///     let result = restart_device(&client, input).await?;
    ///
    ///     // Process the result
    ///     println!("Operation completed successfully");
    ///
    ///     Ok(())
    /// }
    /// ```
    pub async fn restart_device<T: HttpTransport>(client: &RestconfClient<T>, input: RestartDeviceInput) -> Result<RestartDeviceOutput, RpcError> {
        // Serialize input to JSON
        let body = serde_json::to_vec(&input)
            .map_err(|e| RpcError::SerializationError(format!("Failed to serialize input: {}", e)))?;

        // Construct RESTCONF URL
        let base = client.base_url().trim_end_matches('/');
        let url = format!("{}/ restconf/operations/{}:{}", base, percent_encode("test-device"), percent_encode("restart-device"));

        // Build HTTP request
        let request = HttpRequest {
            method: HttpMethod::POST,
            url,
            headers: vec![
                ("Content-Type".to_string(), "application/yang-data+json".to_string()),
                ("Accept".to_string(), "application/yang-data+json".to_string()),
            ],
            body: Some(body),
        };

        // Execute request through client
        let response = client.execute(request).await?;

        // Map HTTP status to error or deserialize response
        match response.status_code {
            200..=299 => {
                // Success - deserialize response body
                serde_json::from_slice(&response.body)
                    .map_err(|e| RpcError::DeserializationError(
                        format!("Failed to deserialize response: {}", e)
                    ))
            }
            _ => Err(RpcError::HttpError {
                status_code: response.status_code,
                message: String::from_utf8_lossy(&response.body).to_string(),
            }),
        }
    }

    /// Output result for get-status RPC.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct GetStatusOutput {
        /// Device uptime in seconds
        #[serde(rename = "uptime", skip_serializing_if = "Option::is_none")]
        pub uptime: Option<u32>,
        /// Current status
        #[serde(rename = "status", skip_serializing_if = "Option::is_none")]
        pub status: Option<String>,
    }

    /// Get device status
    ///
    /// # Arguments
    ///
    /// * `client` - The RestconfClient to use for executing the RPC request
    ///
    /// # Returns
    ///
    /// Returns `Ok(GetStatusOutput)` on success, containing the operation result.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The HTTP request fails (`RpcError::TransportError`)
    /// - The server returns an error status:
    ///   - 400: `RpcError::InvalidInput`
    ///   - 401/403: `RpcError::Unauthorized`
    ///   - 404: `RpcError::NotFound`
    ///   - 500-599: `RpcError::ServerError`
    /// - Response deserialization fails (`RpcError::DeserializationError`)
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// use test_device::*;
    ///
    /// #[tokio::main]
    /// async fn main() -> Result<(), RpcError> {
    ///     // Create a transport adapter
    ///     let transport = reqwest_adapter::ReqwestTransport::new();
    ///
    ///     // Create a client for the RESTCONF server
    ///     let client = RestconfClient::new(
    ///         "https://device.example.com",
    ///         transport
    ///     )?;
    ///
    ///     // Execute the RPC operation
    ///     let result = get_status(&client).await?;
    ///
    ///     // Process the result
    ///     println!("Operation completed successfully");
    ///
    ///     Ok(())
    /// }
    /// ```
    pub async fn get_status<T: HttpTransport>(client: &RestconfClient<T>) -> Result<GetStatusOutput, RpcError> {
        // Construct RESTCONF URL
        let base = client.base_url().trim_end_matches('/');
        let url = format!("{}/ restconf/operations/{}:{}", base, percent_encode("test-device"), percent_encode("get-status"));

        // Build HTTP request
        let request = HttpRequest {
            method: HttpMethod::POST,
            url,
            headers: vec![
                ("Content-Type".to_string(), "application/yang-data+json".to_string()),
                ("Accept".to_string(), "application/yang-data+json".to_string()),
            ],
            body: None,
        };

        // Execute request through client
        let response = client.execute(request).await?;

        // Map HTTP status to error or deserialize response
        match response.status_code {
            200..=299 => {
                // Success - deserialize response body
                serde_json::from_slice(&response.body)
                    .map_err(|e| RpcError::DeserializationError(
                        format!("Failed to deserialize response: {}", e)
                    ))
            }
            _ => Err(RpcError::HttpError {
                status_code: response.status_code,
                message: String::from_utf8_lossy(&response.body).to_string(),
            }),
        }
    }

    /// RESTCONF CRUD operations for data resources.
    pub mod crud {
        use super::*;

        /// Build the RESTCONF URL path for the device container.
        #[allow(dead_code)]
        fn device_path() -> String {
            "/restconf/data/device".to_string()
        }

        /// Retrieve the device container.
        ///
        /// # Errors
        ///
        /// Returns an error if the operation fails.
        pub async fn get_device() -> Result<Device, RpcError> {
            let _path = device_path();
            // TODO: Implement GET request to RESTCONF server
            unimplemented!("GET operation not yet implemented")
        }

        /// Replace the device container.
        ///
        /// # Errors
        ///
        /// Returns an error if the operation fails.
        pub async fn put_device(_data: Device) -> Result<(), RpcError> {
            let _path = device_path();
            // TODO: Implement PUT request to RESTCONF server
            unimplemented!("PUT operation not yet implemented")
        }

        /// Partially update the device container.
        ///
        /// # Errors
        ///
        /// Returns an error if the operation fails.
        pub async fn patch_device(_data: Device) -> Result<(), RpcError> {
            let _path = device_path();
            // TODO: Implement PATCH request to RESTCONF server
            unimplemented!("PATCH operation not yet implemented")
        }

        /// Delete the device container.
        ///
        /// # Errors
        ///
        /// Returns an error if the operation fails.
        pub async fn delete_device() -> Result<(), RpcError> {
            let _path = device_path();
            // TODO: Implement DELETE request to RESTCONF server
            unimplemented!("DELETE operation not yet implemented")
        }

    }
}
